{"/home/travis/build/npmtest/node-npmtest-parsleyjs/test.js":"/* istanbul instrument in package npmtest_parsleyjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/lib.npmtest_parsleyjs.js":"/* istanbul instrument in package npmtest_parsleyjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_parsleyjs = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_parsleyjs = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-parsleyjs && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_parsleyjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_parsleyjs\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_parsleyjs.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_parsleyjs.rollup.js'] =\n            local.assetsDict['/assets.npmtest_parsleyjs.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_parsleyjs.__dirname + '/lib.npmtest_parsleyjs.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/dist/parsley.js":"/*!\n* Parsley.js\n* Version 2.7.0 - built Wed, Mar 1st 2017, 3:53 pm\n* http://parsleyjs.org\n* Guillaume Potier - <guillaume@wisembly.com>\n* Marc-Andre Lafortune - <petroselinum@marc-andre.ca>\n* MIT Licensed\n*/\n\n// The source code below is generated by babel as\n// Parsley is written in ECMAScript 6\n//\nvar _slice = Array.prototype.slice;\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('jquery')) : typeof define === 'function' && define.amd ? define(['jquery'], factory) : global.parsley = factory(global.jQuery);\n})(this, function ($) {\n  'use strict';\n\n  var globalID = 1;\n  var pastWarnings = {};\n\n  var Utils__Utils = {\n    // Parsley DOM-API\n    // returns object from dom attributes and values\n    attr: function attr($element, namespace, obj) {\n      var i;\n      var attribute;\n      var attributes;\n      var regex = new RegExp('^' + namespace, 'i');\n\n      if ('undefined' === typeof obj) obj = {};else {\n        // Clear all own properties. This won't affect prototype's values\n        for (i in obj) {\n          if (obj.hasOwnProperty(i)) delete obj[i];\n        }\n      }\n\n      if ('undefined' === typeof $element || 'undefined' === typeof $element[0]) return obj;\n\n      attributes = $element[0].attributes;\n      for (i = attributes.length; i--;) {\n        attribute = attributes[i];\n\n        if (attribute && attribute.specified && regex.test(attribute.name)) {\n          obj[this.camelize(attribute.name.slice(namespace.length))] = this.deserializeValue(attribute.value);\n        }\n      }\n\n      return obj;\n    },\n\n    checkAttr: function checkAttr($element, namespace, _checkAttr) {\n      return $element.is('[' + namespace + _checkAttr + ']');\n    },\n\n    setAttr: function setAttr($element, namespace, attr, value) {\n      $element[0].setAttribute(this.dasherize(namespace + attr), String(value));\n    },\n\n    generateID: function generateID() {\n      return '' + globalID++;\n    },\n\n    /** Third party functions **/\n    // Zepto deserialize function\n    deserializeValue: function deserializeValue(value) {\n      var num;\n\n      try {\n        return value ? value == \"true\" || (value == \"false\" ? false : value == \"null\" ? null : !isNaN(num = Number(value)) ? num : /^[\\[\\{]/.test(value) ? $.parseJSON(value) : value) : value;\n      } catch (e) {\n        return value;\n      }\n    },\n\n    // Zepto camelize function\n    camelize: function camelize(str) {\n      return str.replace(/-+(.)?/g, function (match, chr) {\n        return chr ? chr.toUpperCase() : '';\n      });\n    },\n\n    // Zepto dasherize function\n    dasherize: function dasherize(str) {\n      return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();\n    },\n\n    warn: function warn() {\n      var _window$console;\n\n      if (window.console && 'function' === typeof window.console.warn) (_window$console = window.console).warn.apply(_window$console, arguments);\n    },\n\n    warnOnce: function warnOnce(msg) {\n      if (!pastWarnings[msg]) {\n        pastWarnings[msg] = true;\n        this.warn.apply(this, arguments);\n      }\n    },\n\n    _resetWarnings: function _resetWarnings() {\n      pastWarnings = {};\n    },\n\n    trimString: function trimString(string) {\n      return string.replace(/^\\s+|\\s+$/g, '');\n    },\n\n    parse: {\n      date: function date(string) {\n        var parsed = string.match(/^(\\d{4,})-(\\d\\d)-(\\d\\d)$/);\n        if (!parsed) return null;\n\n        var _parsed$map = parsed.map(function (x) {\n          return parseInt(x, 10);\n        });\n\n        var _parsed$map2 = _slicedToArray(_parsed$map, 4);\n\n        var _ = _parsed$map2[0];\n        var year = _parsed$map2[1];\n        var month = _parsed$map2[2];\n        var day = _parsed$map2[3];\n\n        var date = new Date(year, month - 1, day);\n        if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) return null;\n        return date;\n      },\n      string: function string(_string) {\n        return _string;\n      },\n      integer: function integer(string) {\n        if (isNaN(string)) return null;\n        return parseInt(string, 10);\n      },\n      number: function number(string) {\n        if (isNaN(string)) throw null;\n        return parseFloat(string);\n      },\n      'boolean': function _boolean(string) {\n        return !/^\\s*false\\s*$/i.test(string);\n      },\n      object: function object(string) {\n        return Utils__Utils.deserializeValue(string);\n      },\n      regexp: function regexp(_regexp) {\n        var flags = '';\n\n        // Test if RegExp is literal, if not, nothing to be done, otherwise, we need to isolate flags and pattern\n        if (/^\\/.*\\/(?:[gimy]*)$/.test(_regexp)) {\n          // Replace the regexp literal string with the first match group: ([gimy]*)\n          // If no flag is present, this will be a blank string\n          flags = _regexp.replace(/.*\\/([gimy]*)$/, '$1');\n          // Again, replace the regexp literal string with the first match group:\n          // everything excluding the opening and closing slashes and the flags\n          _regexp = _regexp.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');\n        } else {\n          // Anchor regexp:\n          _regexp = '^' + _regexp + '$';\n        }\n        return new RegExp(_regexp, flags);\n      }\n    },\n\n    parseRequirement: function parseRequirement(requirementType, string) {\n      var converter = this.parse[requirementType || 'string'];\n      if (!converter) throw 'Unknown requirement specification: \"' + requirementType + '\"';\n      var converted = converter(string);\n      if (converted === null) throw 'Requirement is not a ' + requirementType + ': \"' + string + '\"';\n      return converted;\n    },\n\n    namespaceEvents: function namespaceEvents(events, namespace) {\n      events = this.trimString(events || '').split(/\\s+/);\n      if (!events[0]) return '';\n      return $.map(events, function (evt) {\n        return evt + '.' + namespace;\n      }).join(' ');\n    },\n\n    difference: function difference(array, remove) {\n      // This is O(N^2), should be optimized\n      var result = [];\n      $.each(array, function (_, elem) {\n        if (remove.indexOf(elem) == -1) result.push(elem);\n      });\n      return result;\n    },\n\n    // Alter-ego to native Promise.all, but for jQuery\n    all: function all(promises) {\n      // jQuery treats $.when() and $.when(singlePromise) differently; let's avoid that and add spurious elements\n      return $.when.apply($, _toConsumableArray(promises).concat([42, 42]));\n    },\n\n    // Object.create polyfill, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill\n    objectCreate: Object.create || (function () {\n      var Object = function Object() {};\n      return function (prototype) {\n        if (arguments.length > 1) {\n          throw Error('Second argument not supported');\n        }\n        if (typeof prototype != 'object') {\n          throw TypeError('Argument must be an object');\n        }\n        Object.prototype = prototype;\n        var result = new Object();\n        Object.prototype = null;\n        return result;\n      };\n    })(),\n\n    _SubmitSelector: 'input[type=\"submit\"], button:submit'\n  };\n\n  var Utils__default = Utils__Utils;\n\n  // All these options could be overriden and specified directly in DOM using\n  // `data-parsley-` default DOM-API\n  // eg: `inputs` can be set in DOM using `data-parsley-inputs=\"input, textarea\"`\n  // eg: `data-parsley-stop-on-first-failing-constraint=\"false\"`\n\n  var Defaults = {\n    // ### General\n\n    // Default data-namespace for DOM API\n    namespace: 'data-parsley-',\n\n    // Supported inputs by default\n    inputs: 'input, textarea, select',\n\n    // Excluded inputs by default\n    excluded: 'input[type=button], input[type=submit], input[type=reset], input[type=hidden]',\n\n    // Stop validating field on highest priority failing constraint\n    priorityEnabled: true,\n\n    // ### Field only\n\n    // identifier used to group together inputs (e.g. radio buttons...)\n    multiple: null,\n\n    // identifier (or array of identifiers) used to validate only a select group of inputs\n    group: null,\n\n    // ### UI\n    // Enable\\Disable error messages\n    uiEnabled: true,\n\n    // Key events threshold before validation\n    validationThreshold: 3,\n\n    // Focused field on form validation error. 'first'|'last'|'none'\n    focus: 'first',\n\n    // event(s) that will trigger validation before first failure. eg: `input`...\n    trigger: false,\n\n    // event(s) that will trigger validation after first failure.\n    triggerAfterFailure: 'input',\n\n    // Class that would be added on every failing validation Parsley field\n    errorClass: 'parsley-error',\n\n    // Same for success validation\n    successClass: 'parsley-success',\n\n    // Return the `$element` that will receive these above success or error classes\n    // Could also be (and given directly from DOM) a valid selector like `'#div'`\n    classHandler: function classHandler(Field) {},\n\n    // Return the `$element` where errors will be appended\n    // Could also be (and given directly from DOM) a valid selector like `'#div'`\n    errorsContainer: function errorsContainer(Field) {},\n\n    // ul elem that would receive errors' list\n    errorsWrapper: '<ul class=\"parsley-errors-list\"></ul>',\n\n    // li elem that would receive error message\n    errorTemplate: '<li></li>'\n  };\n\n  var Base = function Base() {\n    this.__id__ = Utils__default.generateID();\n  };\n\n  Base.prototype = {\n    asyncSupport: true, // Deprecated\n\n    _pipeAccordingToValidationResult: function _pipeAccordingToValidationResult() {\n      var _this = this;\n\n      var pipe = function pipe() {\n        var r = $.Deferred();\n        if (true !== _this.validationResult) r.reject();\n        return r.resolve().promise();\n      };\n      return [pipe, pipe];\n    },\n\n    actualizeOptions: function actualizeOptions() {\n      Utils__default.attr(this.$element, this.options.namespace, this.domOptions);\n      if (this.parent && this.parent.actualizeOptions) this.parent.actualizeOptions();\n      return this;\n    },\n\n    _resetOptions: function _resetOptions(initOptions) {\n      this.domOptions = Utils__default.objectCreate(this.parent.options);\n      this.options = Utils__default.objectCreate(this.domOptions);\n      // Shallow copy of ownProperties of initOptions:\n      for (var i in initOptions) {\n        if (initOptions.hasOwnProperty(i)) this.options[i] = initOptions[i];\n      }\n      this.actualizeOptions();\n    },\n\n    _listeners: null,\n\n    // Register a callback for the given event name\n    // Callback is called with context as the first argument and the `this`\n    // The context is the current parsley instance, or window.Parsley if global\n    // A return value of `false` will interrupt the calls\n    on: function on(name, fn) {\n      this._listeners = this._listeners || {};\n      var queue = this._listeners[name] = this._listeners[name] || [];\n      queue.push(fn);\n\n      return this;\n    },\n\n    // Deprecated. Use `on` instead\n    subscribe: function subscribe(name, fn) {\n      $.listenTo(this, name.toLowerCase(), fn);\n    },\n\n    // Unregister a callback (or all if none is given) for the given event name\n    off: function off(name, fn) {\n      var queue = this._listeners && this._listeners[name];\n      if (queue) {\n        if (!fn) {\n          delete this._listeners[name];\n        } else {\n          for (var i = queue.length; i--;) if (queue[i] === fn) queue.splice(i, 1);\n        }\n      }\n      return this;\n    },\n\n    // Deprecated. Use `off`\n    unsubscribe: function unsubscribe(name, fn) {\n      $.unsubscribeTo(this, name.toLowerCase());\n    },\n\n    // Trigger an event of the given name\n    // A return value of `false` interrupts the callback chain\n    // Returns false if execution was interrupted\n    trigger: function trigger(name, target, extraArg) {\n      target = target || this;\n      var queue = this._listeners && this._listeners[name];\n      var result;\n      var parentResult;\n      if (queue) {\n        for (var i = queue.length; i--;) {\n          result = queue[i].call(target, target, extraArg);\n          if (result === false) return result;\n        }\n      }\n      if (this.parent) {\n        return this.parent.trigger(name, target, extraArg);\n      }\n      return true;\n    },\n\n    asyncIsValid: function asyncIsValid(group, force) {\n      Utils__default.warnOnce(\"asyncIsValid is deprecated; please use whenValid instead\");\n      return this.whenValid({ group: group, force: force });\n    },\n\n    _findRelated: function _findRelated() {\n      return this.options.multiple ? this.parent.$element.find('[' + this.options.namespace + 'multiple=\"' + this.options.multiple + '\"]') : this.$element;\n    }\n  };\n\n  var convertArrayRequirement = function convertArrayRequirement(string, length) {\n    var m = string.match(/^\\s*\\[(.*)\\]\\s*$/);\n    if (!m) throw 'Requirement is not an array: \"' + string + '\"';\n    var values = m[1].split(',').map(Utils__default.trimString);\n    if (values.length !== length) throw 'Requirement has ' + values.length + ' values when ' + length + ' are needed';\n    return values;\n  };\n\n  var convertExtraOptionRequirement = function convertExtraOptionRequirement(requirementSpec, string, extraOptionReader) {\n    var main = null;\n    var extra = {};\n    for (var key in requirementSpec) {\n      if (key) {\n        var value = extraOptionReader(key);\n        if ('string' === typeof value) value = Utils__default.parseRequirement(requirementSpec[key], value);\n        extra[key] = value;\n      } else {\n        main = Utils__default.parseRequirement(requirementSpec[key], string);\n      }\n    }\n    return [main, extra];\n  };\n\n  // A Validator needs to implement the methods `validate` and `parseRequirements`\n\n  var Validator = function Validator(spec) {\n    $.extend(true, this, spec);\n  };\n\n  Validator.prototype = {\n    // Returns `true` iff the given `value` is valid according the given requirements.\n    validate: function validate(value, requirementFirstArg) {\n      if (this.fn) {\n        // Legacy style validator\n\n        if (arguments.length > 3) // If more args then value, requirement, instance...\n          requirementFirstArg = [].slice.call(arguments, 1, -1); // Skip first arg (value) and last (instance), combining the rest\n        return this.fn(value, requirementFirstArg);\n      }\n\n      if ($.isArray(value)) {\n        if (!this.validateMultiple) throw 'Validator `' + this.name + '` does not handle multiple values';\n        return this.validateMultiple.apply(this, arguments);\n      } else {\n        var instance = arguments[arguments.length - 1];\n        if (this.validateDate && instance._isDateInput()) {\n          arguments[0] = Utils__default.parse.date(arguments[0]);\n          if (arguments[0] === null) return false;\n          return this.validateDate.apply(this, arguments);\n        }\n        if (this.validateNumber) {\n          if (isNaN(value)) return false;\n          arguments[0] = parseFloat(arguments[0]);\n          return this.validateNumber.apply(this, arguments);\n        }\n        if (this.validateString) {\n          return this.validateString.apply(this, arguments);\n        }\n        throw 'Validator `' + this.name + '` only handles multiple values';\n      }\n    },\n\n    // Parses `requirements` into an array of arguments,\n    // according to `this.requirementType`\n    parseRequirements: function parseRequirements(requirements, extraOptionReader) {\n      if ('string' !== typeof requirements) {\n        // Assume requirement already parsed\n        // but make sure we return an array\n        return $.isArray(requirements) ? requirements : [requirements];\n      }\n      var type = this.requirementType;\n      if ($.isArray(type)) {\n        var values = convertArrayRequirement(requirements, type.length);\n        for (var i = 0; i < values.length; i++) values[i] = Utils__default.parseRequirement(type[i], values[i]);\n        return values;\n      } else if ($.isPlainObject(type)) {\n        return convertExtraOptionRequirement(type, requirements, extraOptionReader);\n      } else {\n        return [Utils__default.parseRequirement(type, requirements)];\n      }\n    },\n    // Defaults:\n    requirementType: 'string',\n\n    priority: 2\n\n  };\n\n  var ValidatorRegistry = function ValidatorRegistry(validators, catalog) {\n    this.__class__ = 'ValidatorRegistry';\n\n    // Default Parsley locale is en\n    this.locale = 'en';\n\n    this.init(validators || {}, catalog || {});\n  };\n\n  var typeTesters = {\n    email: /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i,\n\n    // Follow https://www.w3.org/TR/html5/infrastructure.html#floating-point-numbers\n    number: /^-?(\\d*\\.)?\\d+(e[-+]?\\d+)?$/i,\n\n    integer: /^-?\\d+$/,\n\n    digits: /^\\d+$/,\n\n    alphanum: /^\\w+$/i,\n\n    date: {\n      test: function test(value) {\n        return Utils__default.parse.date(value) !== null;\n      }\n    },\n\n    url: new RegExp(\"^\" +\n    // protocol identifier\n    \"(?:(?:https?|ftp)://)?\" + // ** mod: make scheme optional\n    // user:pass authentication\n    \"(?:\\\\S+(?::\\\\S*)?@)?\" + \"(?:\" +\n    // IP address exclusion\n    // private & local networks\n    // \"(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})\" +   // ** mod: allow local networks\n    // \"(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n    // \"(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n    // IP address dotted notation octets\n    // excludes loopback network 0.0.0.0\n    // excludes reserved space >= 224.0.0.0\n    // excludes network & broacast addresses\n    // (first & last IP address of each class)\n    \"(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])\" + \"(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}\" + \"(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))\" + \"|\" +\n    // host name\n    '(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)' +\n    // domain name\n    '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*' +\n    // TLD identifier\n    '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))' + \")\" +\n    // port number\n    \"(?::\\\\d{2,5})?\" +\n    // resource path\n    \"(?:/\\\\S*)?\" + \"$\", 'i')\n  };\n  typeTesters.range = typeTesters.number;\n\n  // See http://stackoverflow.com/a/10454560/8279\n  var decimalPlaces = function decimalPlaces(num) {\n    var match = ('' + num).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n    if (!match) {\n      return 0;\n    }\n    return Math.max(0,\n    // Number of digits right of decimal point.\n    (match[1] ? match[1].length : 0) - (\n    // Adjust for scientific notation.\n    match[2] ? +match[2] : 0));\n  };\n\n  // parseArguments('number', ['1', '2']) => [1, 2]\n  var ValidatorRegistry__parseArguments = function ValidatorRegistry__parseArguments(type, args) {\n    return args.map(Utils__default.parse[type]);\n  };\n  // operatorToValidator returns a validating function for an operator function, applied to the given type\n  var ValidatorRegistry__operatorToValidator = function ValidatorRegistry__operatorToValidator(type, operator) {\n    return function (value) {\n      for (var _len = arguments.length, requirementsAndInput = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        requirementsAndInput[_key - 1] = arguments[_key];\n      }\n\n      requirementsAndInput.pop(); // Get rid of `input` argument\n      return operator.apply(undefined, [value].concat(_toConsumableArray(ValidatorRegistry__parseArguments(type, requirementsAndInput))));\n    };\n  };\n\n  var ValidatorRegistry__comparisonOperator = function ValidatorRegistry__comparisonOperator(operator) {\n    return {\n      validateDate: ValidatorRegistry__operatorToValidator('date', operator),\n      validateNumber: ValidatorRegistry__operatorToValidator('number', operator),\n      requirementType: operator.length <= 2 ? 'string' : ['string', 'string'], // Support operators with a 1 or 2 requirement(s)\n      priority: 30\n    };\n  };\n\n  ValidatorRegistry.prototype = {\n    init: function init(validators, catalog) {\n      this.catalog = catalog;\n      // Copy prototype's validators:\n      this.validators = $.extend({}, this.validators);\n\n      for (var name in validators) this.addValidator(name, validators[name].fn, validators[name].priority);\n\n      window.Parsley.trigger('parsley:validator:init');\n    },\n\n    // Set new messages locale if we have dictionary loaded in ParsleyConfig.i18n\n    setLocale: function setLocale(locale) {\n      if ('undefined' === typeof this.catalog[locale]) throw new Error(locale + ' is not available in the catalog');\n\n      this.locale = locale;\n\n      return this;\n    },\n\n    // Add a new messages catalog for a given locale. Set locale for this catalog if set === `true`\n    addCatalog: function addCatalog(locale, messages, set) {\n      if ('object' === typeof messages) this.catalog[locale] = messages;\n\n      if (true === set) return this.setLocale(locale);\n\n      return this;\n    },\n\n    // Add a specific message for a given constraint in a given locale\n    addMessage: function addMessage(locale, name, message) {\n      if ('undefined' === typeof this.catalog[locale]) this.catalog[locale] = {};\n\n      this.catalog[locale][name] = message;\n\n      return this;\n    },\n\n    // Add messages for a given locale\n    addMessages: function addMessages(locale, nameMessageObject) {\n      for (var name in nameMessageObject) this.addMessage(locale, name, nameMessageObject[name]);\n\n      return this;\n    },\n\n    // Add a new validator\n    //\n    //    addValidator('custom', {\n    //        requirementType: ['integer', 'integer'],\n    //        validateString: function(value, from, to) {},\n    //        priority: 22,\n    //        messages: {\n    //          en: \"Hey, that's no good\",\n    //          fr: \"Aye aye, pas bon du tout\",\n    //        }\n    //    })\n    //\n    // Old API was addValidator(name, function, priority)\n    //\n    addValidator: function addValidator(name, arg1, arg2) {\n      if (this.validators[name]) Utils__default.warn('Validator \"' + name + '\" is already defined.');else if (Defaults.hasOwnProperty(name)) {\n        Utils__default.warn('\"' + name + '\" is a restricted keyword and is not a valid validator name.');\n        return;\n      }\n      return this._setValidator.apply(this, arguments);\n    },\n\n    updateValidator: function updateValidator(name, arg1, arg2) {\n      if (!this.validators[name]) {\n        Utils__default.warn('Validator \"' + name + '\" is not already defined.');\n        return this.addValidator.apply(this, arguments);\n      }\n      return this._setValidator.apply(this, arguments);\n    },\n\n    removeValidator: function removeValidator(name) {\n      if (!this.validators[name]) Utils__default.warn('Validator \"' + name + '\" is not defined.');\n\n      delete this.validators[name];\n\n      return this;\n    },\n\n    _setValidator: function _setValidator(name, validator, priority) {\n      if ('object' !== typeof validator) {\n        // Old style validator, with `fn` and `priority`\n        validator = {\n          fn: validator,\n          priority: priority\n        };\n      }\n      if (!validator.validate) {\n        validator = new Validator(validator);\n      }\n      this.validators[name] = validator;\n\n      for (var locale in validator.messages || {}) this.addMessage(locale, name, validator.messages[locale]);\n\n      return this;\n    },\n\n    getErrorMessage: function getErrorMessage(constraint) {\n      var message;\n\n      // Type constraints are a bit different, we have to match their requirements too to find right error message\n      if ('type' === constraint.name) {\n        var typeMessages = this.catalog[this.locale][constraint.name] || {};\n        message = typeMessages[constraint.requirements];\n      } else message = this.formatMessage(this.catalog[this.locale][constraint.name], constraint.requirements);\n\n      return message || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage;\n    },\n\n    // Kind of light `sprintf()` implementation\n    formatMessage: function formatMessage(string, parameters) {\n      if ('object' === typeof parameters) {\n        for (var i in parameters) string = this.formatMessage(string, parameters[i]);\n\n        return string;\n      }\n\n      return 'string' === typeof string ? string.replace(/%s/i, parameters) : '';\n    },\n\n    // Here is the Parsley default validators list.\n    // A validator is an object with the following key values:\n    //  - priority: an integer\n    //  - requirement: 'string' (default), 'integer', 'number', 'regexp' or an Array of these\n    //  - validateString, validateMultiple, validateNumber: functions returning `true`, `false` or a promise\n    // Alternatively, a validator can be a function that returns such an object\n    //\n    validators: {\n      notblank: {\n        validateString: function validateString(value) {\n          return (/\\S/.test(value)\n          );\n        },\n        priority: 2\n      },\n      required: {\n        validateMultiple: function validateMultiple(values) {\n          return values.length > 0;\n        },\n        validateString: function validateString(value) {\n          return (/\\S/.test(value)\n          );\n        },\n        priority: 512\n      },\n      type: {\n        validateString: function validateString(value, type) {\n          var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n          var _ref$step = _ref.step;\n          var step = _ref$step === undefined ? 'any' : _ref$step;\n          var _ref$base = _ref.base;\n          var base = _ref$base === undefined ? 0 : _ref$base;\n\n          var tester = typeTesters[type];\n          if (!tester) {\n            throw new Error('validator type `' + type + '` is not supported');\n          }\n          if (!tester.test(value)) return false;\n          if ('number' === type) {\n            if (!/^any$/i.test(step || '')) {\n              var nb = Number(value);\n              var decimals = Math.max(decimalPlaces(step), decimalPlaces(base));\n              if (decimalPlaces(nb) > decimals) // Value can't have too many decimals\n                return false;\n              // Be careful of rounding errors by using integers.\n              var toInt = function toInt(f) {\n                return Math.round(f * Math.pow(10, decimals));\n              };\n              if ((toInt(nb) - toInt(base)) % toInt(step) != 0) return false;\n            }\n          }\n          return true;\n        },\n        requirementType: {\n          '': 'string',\n          step: 'string',\n          base: 'number'\n        },\n        priority: 256\n      },\n      pattern: {\n        validateString: function validateString(value, regexp) {\n          return regexp.test(value);\n        },\n        requirementType: 'regexp',\n        priority: 64\n      },\n      minlength: {\n        validateString: function validateString(value, requirement) {\n          return value.length >= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      maxlength: {\n        validateString: function validateString(value, requirement) {\n          return value.length <= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      length: {\n        validateString: function validateString(value, min, max) {\n          return value.length >= min && value.length <= max;\n        },\n        requirementType: ['integer', 'integer'],\n        priority: 30\n      },\n      mincheck: {\n        validateMultiple: function validateMultiple(values, requirement) {\n          return values.length >= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      maxcheck: {\n        validateMultiple: function validateMultiple(values, requirement) {\n          return values.length <= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      check: {\n        validateMultiple: function validateMultiple(values, min, max) {\n          return values.length >= min && values.length <= max;\n        },\n        requirementType: ['integer', 'integer'],\n        priority: 30\n      },\n      min: ValidatorRegistry__comparisonOperator(function (value, requirement) {\n        return value >= requirement;\n      }),\n      max: ValidatorRegistry__comparisonOperator(function (value, requirement) {\n        return value <= requirement;\n      }),\n      range: ValidatorRegistry__comparisonOperator(function (value, min, max) {\n        return value >= min && value <= max;\n      }),\n      equalto: {\n        validateString: function validateString(value, refOrValue) {\n          var $reference = $(refOrValue);\n          if ($reference.length) return value === $reference.val();else return value === refOrValue;\n        },\n        priority: 256\n      }\n    }\n  };\n\n  var UI = {};\n\n  var diffResults = function diffResults(newResult, oldResult, deep) {\n    var added = [];\n    var kept = [];\n\n    for (var i = 0; i < newResult.length; i++) {\n      var found = false;\n\n      for (var j = 0; j < oldResult.length; j++) if (newResult[i].assert.name === oldResult[j].assert.name) {\n        found = true;\n        break;\n      }\n\n      if (found) kept.push(newResult[i]);else added.push(newResult[i]);\n    }\n\n    return {\n      kept: kept,\n      added: added,\n      removed: !deep ? diffResults(oldResult, newResult, true).added : []\n    };\n  };\n\n  UI.Form = {\n\n    _actualizeTriggers: function _actualizeTriggers() {\n      var _this2 = this;\n\n      this.$element.on('submit.Parsley', function (evt) {\n        _this2.onSubmitValidate(evt);\n      });\n      this.$element.on('click.Parsley', Utils__default._SubmitSelector, function (evt) {\n        _this2.onSubmitButton(evt);\n      });\n\n      // UI could be disabled\n      if (false === this.options.uiEnabled) return;\n\n      this.$element.attr('novalidate', '');\n    },\n\n    focus: function focus() {\n      this._focusedField = null;\n\n      if (true === this.validationResult || 'none' === this.options.focus) return null;\n\n      for (var i = 0; i < this.fields.length; i++) {\n        var field = this.fields[i];\n        if (true !== field.validationResult && field.validationResult.length > 0 && 'undefined' === typeof field.options.noFocus) {\n          this._focusedField = field.$element;\n          if ('first' === this.options.focus) break;\n        }\n      }\n\n      if (null === this._focusedField) return null;\n\n      return this._focusedField.focus();\n    },\n\n    _destroyUI: function _destroyUI() {\n      // Reset all event listeners\n      this.$element.off('.Parsley');\n    }\n\n  };\n\n  UI.Field = {\n\n    _reflowUI: function _reflowUI() {\n      this._buildUI();\n\n      // If this field doesn't have an active UI don't bother doing something\n      if (!this._ui) return;\n\n      // Diff between two validation results\n      var diff = diffResults(this.validationResult, this._ui.lastValidationResult);\n\n      // Then store current validation result for next reflow\n      this._ui.lastValidationResult = this.validationResult;\n\n      // Handle valid / invalid / none field class\n      this._manageStatusClass();\n\n      // Add, remove, updated errors messages\n      this._manageErrorsMessages(diff);\n\n      // Triggers impl\n      this._actualizeTriggers();\n\n      // If field is not valid for the first time, bind keyup trigger to ease UX and quickly inform user\n      if ((diff.kept.length || diff.added.length) && !this._failedOnce) {\n        this._failedOnce = true;\n        this._actualizeTriggers();\n      }\n    },\n\n    // Returns an array of field's error message(s)\n    getErrorsMessages: function getErrorsMessages() {\n      // No error message, field is valid\n      if (true === this.validationResult) return [];\n\n      var messages = [];\n\n      for (var i = 0; i < this.validationResult.length; i++) messages.push(this.validationResult[i].errorMessage || this._getErrorMessage(this.validationResult[i].assert));\n\n      return messages;\n    },\n\n    // It's a goal of Parsley that this method is no longer required [#1073]\n    addError: function addError(name) {\n      var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var message = _ref2.message;\n      var assert = _ref2.assert;\n      var _ref2$updateClass = _ref2.updateClass;\n      var updateClass = _ref2$updateClass === undefined ? true : _ref2$updateClass;\n\n      this._buildUI();\n      this._addError(name, { message: message, assert: assert });\n\n      if (updateClass) this._errorClass();\n    },\n\n    // It's a goal of Parsley that this method is no longer required [#1073]\n    updateError: function updateError(name) {\n      var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var message = _ref3.message;\n      var assert = _ref3.assert;\n      var _ref3$updateClass = _ref3.updateClass;\n      var updateClass = _ref3$updateClass === undefined ? true : _ref3$updateClass;\n\n      this._buildUI();\n      this._updateError(name, { message: message, assert: assert });\n\n      if (updateClass) this._errorClass();\n    },\n\n    // It's a goal of Parsley that this method is no longer required [#1073]\n    removeError: function removeError(name) {\n      var _ref4 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var _ref4$updateClass = _ref4.updateClass;\n      var updateClass = _ref4$updateClass === undefined ? true : _ref4$updateClass;\n\n      this._buildUI();\n      this._removeError(name);\n\n      // edge case possible here: remove a standard Parsley error that is still failing in this.validationResult\n      // but highly improbable cuz' manually removing a well Parsley handled error makes no sense.\n      if (updateClass) this._manageStatusClass();\n    },\n\n    _manageStatusClass: function _manageStatusClass() {\n      if (this.hasConstraints() && this.needsValidation() && true === this.validationResult) this._successClass();else if (this.validationResult.length > 0) this._errorClass();else this._resetClass();\n    },\n\n    _manageErrorsMessages: function _manageErrorsMessages(diff) {\n      if ('undefined' !== typeof this.options.errorsMessagesDisabled) return;\n\n      // Case where we have errorMessage option that configure an unique field error message, regardless failing validators\n      if ('undefined' !== typeof this.options.errorMessage) {\n        if (diff.added.length || diff.kept.length) {\n          this._insertErrorWrapper();\n\n          if (0 === this._ui.$errorsWrapper.find('.parsley-custom-error-message').length) this._ui.$errorsWrapper.append($(this.options.errorTemplate).addClass('parsley-custom-error-message'));\n\n          return this._ui.$errorsWrapper.addClass('filled').find('.parsley-custom-error-message').html(this.options.errorMessage);\n        }\n\n        return this._ui.$errorsWrapper.removeClass('filled').find('.parsley-custom-error-message').remove();\n      }\n\n      // Show, hide, update failing constraints messages\n      for (var i = 0; i < diff.removed.length; i++) this._removeError(diff.removed[i].assert.name);\n\n      for (i = 0; i < diff.added.length; i++) this._addError(diff.added[i].assert.name, { message: diff.added[i].errorMessage, assert: diff.added[i].assert });\n\n      for (i = 0; i < diff.kept.length; i++) this._updateError(diff.kept[i].assert.name, { message: diff.kept[i].errorMessage, assert: diff.kept[i].assert });\n    },\n\n    _addError: function _addError(name, _ref5) {\n      var message = _ref5.message;\n      var assert = _ref5.assert;\n\n      this._insertErrorWrapper();\n      this._ui.$errorsWrapper.addClass('filled').append($(this.options.errorTemplate).addClass('parsley-' + name).html(message || this._getErrorMessage(assert)));\n    },\n\n    _updateError: function _updateError(name, _ref6) {\n      var message = _ref6.message;\n      var assert = _ref6.assert;\n\n      this._ui.$errorsWrapper.addClass('filled').find('.parsley-' + name).html(message || this._getErrorMessage(assert));\n    },\n\n    _removeError: function _removeError(name) {\n      this._ui.$errorsWrapper.removeClass('filled').find('.parsley-' + name).remove();\n    },\n\n    _getErrorMessage: function _getErrorMessage(constraint) {\n      var customConstraintErrorMessage = constraint.name + 'Message';\n\n      if ('undefined' !== typeof this.options[customConstraintErrorMessage]) return window.Parsley.formatMessage(this.options[customConstraintErrorMessage], constraint.requirements);\n\n      return window.Parsley.getErrorMessage(constraint);\n    },\n\n    _buildUI: function _buildUI() {\n      // UI could be already built or disabled\n      if (this._ui || false === this.options.uiEnabled) return;\n\n      var _ui = {};\n\n      // Give field its Parsley id in DOM\n      this.$element.attr(this.options.namespace + 'id', this.__id__);\n\n      /** Generate important UI elements and store them in this **/\n      // $errorClassHandler is the $element that woul have parsley-error and parsley-success classes\n      _ui.$errorClassHandler = this._manageClassHandler();\n\n      // $errorsWrapper is a div that would contain the various field errors, it will be appended into $errorsContainer\n      _ui.errorsWrapperId = 'parsley-id-' + (this.options.multiple ? 'multiple-' + this.options.multiple : this.__id__);\n      _ui.$errorsWrapper = $(this.options.errorsWrapper).attr('id', _ui.errorsWrapperId);\n\n      // ValidationResult UI storage to detect what have changed bwt two validations, and update DOM accordingly\n      _ui.lastValidationResult = [];\n      _ui.validationInformationVisible = false;\n\n      // Store it in this for later\n      this._ui = _ui;\n    },\n\n    // Determine which element will have `parsley-error` and `parsley-success` classes\n    _manageClassHandler: function _manageClassHandler() {\n      // An element selector could be passed through DOM with `data-parsley-class-handler=#foo`\n      if ('string' === typeof this.options.classHandler && $(this.options.classHandler).length) return $(this.options.classHandler);\n\n      // Class handled could also be determined by function given in Parsley options\n      var $handler = this.options.classHandler.call(this, this);\n\n      // If this function returned a valid existing DOM element, go for it\n      if ('undefined' !== typeof $handler && $handler.length) return $handler;\n\n      return this._inputHolder();\n    },\n\n    _inputHolder: function _inputHolder() {\n      // if simple element (input, texatrea, select...) it will perfectly host the classes and precede the error container\n      if (!this.options.multiple || this.$element.is('select')) return this.$element;\n\n      // But if multiple element (radio, checkbox), that would be their parent\n      return this.$element.parent();\n    },\n\n    _insertErrorWrapper: function _insertErrorWrapper() {\n      var $errorsContainer;\n\n      // Nothing to do if already inserted\n      if (0 !== this._ui.$errorsWrapper.parent().length) return this._ui.$errorsWrapper.parent();\n\n      if ('string' === typeof this.options.errorsContainer) {\n        if ($(this.options.errorsContainer).length) return $(this.options.errorsContainer).append(this._ui.$errorsWrapper);else Utils__default.warn('The errors container `' + this.options.errorsContainer + '` does not exist in DOM');\n      } else if ('function' === typeof this.options.errorsContainer) $errorsContainer = this.options.errorsContainer.call(this, this);\n\n      if ('undefined' !== typeof $errorsContainer && $errorsContainer.length) return $errorsContainer.append(this._ui.$errorsWrapper);\n\n      return this._inputHolder().after(this._ui.$errorsWrapper);\n    },\n\n    _actualizeTriggers: function _actualizeTriggers() {\n      var _this3 = this;\n\n      var $toBind = this._findRelated();\n      var trigger;\n\n      // Remove Parsley events already bound on this field\n      $toBind.off('.Parsley');\n      if (this._failedOnce) $toBind.on(Utils__default.namespaceEvents(this.options.triggerAfterFailure, 'Parsley'), function () {\n        _this3._validateIfNeeded();\n      });else if (trigger = Utils__default.namespaceEvents(this.options.trigger, 'Parsley')) {\n        $toBind.on(trigger, function (event) {\n          _this3._validateIfNeeded(event);\n        });\n      }\n    },\n\n    _validateIfNeeded: function _validateIfNeeded(event) {\n      var _this4 = this;\n\n      // For keyup, keypress, keydown, input... events that could be a little bit obstrusive\n      // do not validate if val length < min threshold on first validation. Once field have been validated once and info\n      // about success or failure have been displayed, always validate with this trigger to reflect every yalidation change.\n      if (event && /key|input/.test(event.type)) if (!(this._ui && this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold) return;\n\n      if (this.options.debounce) {\n        window.clearTimeout(this._debounced);\n        this._debounced = window.setTimeout(function () {\n          return _this4.validate();\n        }, this.options.debounce);\n      } else this.validate();\n    },\n\n    _resetUI: function _resetUI() {\n      // Reset all event listeners\n      this._failedOnce = false;\n      this._actualizeTriggers();\n\n      // Nothing to do if UI never initialized for this field\n      if ('undefined' === typeof this._ui) return;\n\n      // Reset all errors' li\n      this._ui.$errorsWrapper.removeClass('filled').children().remove();\n\n      // Reset validation class\n      this._resetClass();\n\n      // Reset validation flags and last validation result\n      this._ui.lastValidationResult = [];\n      this._ui.validationInformationVisible = false;\n    },\n\n    _destroyUI: function _destroyUI() {\n      this._resetUI();\n\n      if ('undefined' !== typeof this._ui) this._ui.$errorsWrapper.remove();\n\n      delete this._ui;\n    },\n\n    _successClass: function _successClass() {\n      this._ui.validationInformationVisible = true;\n      this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass);\n    },\n    _errorClass: function _errorClass() {\n      this._ui.validationInformationVisible = true;\n      this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass);\n    },\n    _resetClass: function _resetClass() {\n      this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass);\n    }\n  };\n\n  var Form = function Form(element, domOptions, options) {\n    this.__class__ = 'Form';\n\n    this.$element = $(element);\n    this.domOptions = domOptions;\n    this.options = options;\n    this.parent = window.Parsley;\n\n    this.fields = [];\n    this.validationResult = null;\n  };\n\n  var Form__statusMapping = { pending: null, resolved: true, rejected: false };\n\n  Form.prototype = {\n    onSubmitValidate: function onSubmitValidate(event) {\n      var _this5 = this;\n\n      // This is a Parsley generated submit event, do not validate, do not prevent, simply exit and keep normal behavior\n      if (true === event.parsley) return;\n\n      // If we didn't come here through a submit button, use the first one in the form\n      var $submitSource = this._$submitSource || this.$element.find(Utils__default._SubmitSelector).first();\n      this._$submitSource = null;\n      this.$element.find('.parsley-synthetic-submit-button').prop('disabled', true);\n      if ($submitSource.is('[formnovalidate]')) return;\n\n      var promise = this.whenValidate({ event: event });\n\n      if ('resolved' === promise.state() && false !== this._trigger('submit')) {\n        // All good, let event go through. We make this distinction because browsers\n        // differ in their handling of `submit` being called from inside a submit event [#1047]\n      } else {\n          // Rejected or pending: cancel this submit\n          event.stopImmediatePropagation();\n          event.preventDefault();\n          if ('pending' === promise.state()) promise.done(function () {\n            _this5._submit($submitSource);\n          });\n        }\n    },\n\n    onSubmitButton: function onSubmitButton(event) {\n      this._$submitSource = $(event.currentTarget);\n    },\n    // internal\n    // _submit submits the form, this time without going through the validations.\n    // Care must be taken to \"fake\" the actual submit button being clicked.\n    _submit: function _submit($submitSource) {\n      if (false === this._trigger('submit')) return;\n      // Add submit button's data\n      if ($submitSource) {\n        var $synthetic = this.$element.find('.parsley-synthetic-submit-button').prop('disabled', false);\n        if (0 === $synthetic.length) $synthetic = $('<input class=\"parsley-synthetic-submit-button\" type=\"hidden\">').appendTo(this.$element);\n        $synthetic.attr({\n          name: $submitSource.attr('name'),\n          value: $submitSource.attr('value')\n        });\n      }\n\n      this.$element.trigger($.extend($.Event('submit'), { parsley: true }));\n    },\n\n    // Performs validation on fields while triggering events.\n    // @returns `true` if all validations succeeds, `false`\n    // if a failure is immediately detected, or `null`\n    // if dependant on a promise.\n    // Consider using `whenValidate` instead.\n    validate: function validate(options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        Utils__default.warnOnce('Calling validate on a parsley form without passing arguments as an object is deprecated.');\n\n        var _arguments = _slice.call(arguments);\n\n        var group = _arguments[0];\n        var force = _arguments[1];\n        var event = _arguments[2];\n\n        options = { group: group, force: force, event: event };\n      }\n      return Form__statusMapping[this.whenValidate(options).state()];\n    },\n\n    whenValidate: function whenValidate() {\n      var _Utils__default$all$done$fail$always,\n          _this6 = this;\n\n      var _ref7 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var group = _ref7.group;\n      var force = _ref7.force;\n      var event = _ref7.event;\n\n      this.submitEvent = event;\n      if (event) {\n        this.submitEvent = $.extend({}, event, { preventDefault: function preventDefault() {\n            Utils__default.warnOnce(\"Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`\");\n            _this6.validationResult = false;\n          } });\n      }\n      this.validationResult = true;\n\n      // fire validate event to eventually modify things before every validation\n      this._trigger('validate');\n\n      // Refresh form DOM options and form's fields that could have changed\n      this._refreshFields();\n\n      var promises = this._withoutReactualizingFormOptions(function () {\n        return $.map(_this6.fields, function (field) {\n          return field.whenValidate({ force: force, group: group });\n        });\n      });\n\n      return (_Utils__default$all$done$fail$always = Utils__default.all(promises).done(function () {\n        _this6._trigger('success');\n      }).fail(function () {\n        _this6.validationResult = false;\n        _this6.focus();\n        _this6._trigger('error');\n      }).always(function () {\n        _this6._trigger('validated');\n      })).pipe.apply(_Utils__default$all$done$fail$always, _toConsumableArray(this._pipeAccordingToValidationResult()));\n    },\n\n    // Iterate over refreshed fields, and stop on first failure.\n    // Returns `true` if all fields are valid, `false` if a failure is detected\n    // or `null` if the result depends on an unresolved promise.\n    // Prefer using `whenValid` instead.\n    isValid: function isValid(options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        Utils__default.warnOnce('Calling isValid on a parsley form without passing arguments as an object is deprecated.');\n\n        var _arguments2 = _slice.call(arguments);\n\n        var group = _arguments2[0];\n        var force = _arguments2[1];\n\n        options = { group: group, force: force };\n      }\n      return Form__statusMapping[this.whenValid(options).state()];\n    },\n\n    // Iterate over refreshed fields and validate them.\n    // Returns a promise.\n    // A validation that immediately fails will interrupt the validations.\n    whenValid: function whenValid() {\n      var _this7 = this;\n\n      var _ref8 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var group = _ref8.group;\n      var force = _ref8.force;\n\n      this._refreshFields();\n\n      var promises = this._withoutReactualizingFormOptions(function () {\n        return $.map(_this7.fields, function (field) {\n          return field.whenValid({ group: group, force: force });\n        });\n      });\n      return Utils__default.all(promises);\n    },\n\n    // Reset UI\n    reset: function reset() {\n      // Form case: emit a reset event for each field\n      for (var i = 0; i < this.fields.length; i++) this.fields[i].reset();\n\n      this._trigger('reset');\n    },\n\n    // Destroy Parsley instance (+ UI)\n    destroy: function destroy() {\n      // Field case: emit destroy event to clean UI and then destroy stored instance\n      this._destroyUI();\n\n      // Form case: destroy all its fields and then destroy stored instance\n      for (var i = 0; i < this.fields.length; i++) this.fields[i].destroy();\n\n      this.$element.removeData('Parsley');\n      this._trigger('destroy');\n    },\n\n    _refreshFields: function _refreshFields() {\n      return this.actualizeOptions()._bindFields();\n    },\n\n    _bindFields: function _bindFields() {\n      var _this8 = this;\n\n      var oldFields = this.fields;\n\n      this.fields = [];\n      this.fieldsMappedById = {};\n\n      this._withoutReactualizingFormOptions(function () {\n        _this8.$element.find(_this8.options.inputs).not(_this8.options.excluded).each(function (_, element) {\n          var fieldInstance = new window.Parsley.Factory(element, {}, _this8);\n\n          // Only add valid and not excluded `Field` and `FieldMultiple` children\n          if (('Field' === fieldInstance.__class__ || 'FieldMultiple' === fieldInstance.__class__) && true !== fieldInstance.options.excluded) {\n            var uniqueId = fieldInstance.__class__ + '-' + fieldInstance.__id__;\n            if ('undefined' === typeof _this8.fieldsMappedById[uniqueId]) {\n              _this8.fieldsMappedById[uniqueId] = fieldInstance;\n              _this8.fields.push(fieldInstance);\n            }\n          }\n        });\n\n        $.each(Utils__default.difference(oldFields, _this8.fields), function (_, field) {\n          field.reset();\n        });\n      });\n      return this;\n    },\n\n    // Internal only.\n    // Looping on a form's fields to do validation or similar\n    // will trigger reactualizing options on all of them, which\n    // in turn will reactualize the form's options.\n    // To avoid calling actualizeOptions so many times on the form\n    // for nothing, _withoutReactualizingFormOptions temporarily disables\n    // the method actualizeOptions on this form while `fn` is called.\n    _withoutReactualizingFormOptions: function _withoutReactualizingFormOptions(fn) {\n      var oldActualizeOptions = this.actualizeOptions;\n      this.actualizeOptions = function () {\n        return this;\n      };\n      var result = fn();\n      this.actualizeOptions = oldActualizeOptions;\n      return result;\n    },\n\n    // Internal only.\n    // Shortcut to trigger an event\n    // Returns true iff event is not interrupted and default not prevented.\n    _trigger: function _trigger(eventName) {\n      return this.trigger('form:' + eventName);\n    }\n\n  };\n\n  var Constraint = function Constraint(parsleyField, name, requirements, priority, isDomConstraint) {\n    var validatorSpec = window.Parsley._validatorRegistry.validators[name];\n    var validator = new Validator(validatorSpec);\n\n    $.extend(this, {\n      validator: validator,\n      name: name,\n      requirements: requirements,\n      priority: priority || parsleyField.options[name + 'Priority'] || validator.priority,\n      isDomConstraint: true === isDomConstraint\n    });\n    this._parseRequirements(parsleyField.options);\n  };\n\n  var capitalize = function capitalize(str) {\n    var cap = str[0].toUpperCase();\n    return cap + str.slice(1);\n  };\n\n  Constraint.prototype = {\n    validate: function validate(value, instance) {\n      var _validator;\n\n      return (_validator = this.validator).validate.apply(_validator, [value].concat(_toConsumableArray(this.requirementList), [instance]));\n    },\n\n    _parseRequirements: function _parseRequirements(options) {\n      var _this9 = this;\n\n      this.requirementList = this.validator.parseRequirements(this.requirements, function (key) {\n        return options[_this9.name + capitalize(key)];\n      });\n    }\n  };\n\n  var Field = function Field(field, domOptions, options, parsleyFormInstance) {\n    this.__class__ = 'Field';\n\n    this.$element = $(field);\n\n    // Set parent if we have one\n    if ('undefined' !== typeof parsleyFormInstance) {\n      this.parent = parsleyFormInstance;\n    }\n\n    this.options = options;\n    this.domOptions = domOptions;\n\n    // Initialize some properties\n    this.constraints = [];\n    this.constraintsByName = {};\n    this.validationResult = true;\n\n    // Bind constraints\n    this._bindConstraints();\n  };\n\n  var parsley_field__statusMapping = { pending: null, resolved: true, rejected: false };\n\n  Field.prototype = {\n    // # Public API\n    // Validate field and trigger some events for mainly `UI`\n    // @returns `true`, an array of the validators that failed, or\n    // `null` if validation is not finished. Prefer using whenValidate\n    validate: function validate(options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        Utils__default.warnOnce('Calling validate on a parsley field without passing arguments as an object is deprecated.');\n        options = { options: options };\n      }\n      var promise = this.whenValidate(options);\n      if (!promise) // If excluded with `group` option\n        return true;\n      switch (promise.state()) {\n        case 'pending':\n          return null;\n        case 'resolved':\n          return true;\n        case 'rejected':\n          return this.validationResult;\n      }\n    },\n\n    // Validate field and trigger some events for mainly `UI`\n    // @returns a promise that succeeds only when all validations do\n    // or `undefined` if field is not in the given `group`.\n    whenValidate: function whenValidate() {\n      var _whenValid$always$done$fail$always,\n          _this10 = this;\n\n      var _ref9 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var force = _ref9.force;\n      var group = _ref9.group;\n\n      // do not validate a field if not the same as given validation group\n      this.refreshConstraints();\n      if (group && !this._isInGroup(group)) return;\n\n      this.value = this.getValue();\n\n      // Field Validate event. `this.value` could be altered for custom needs\n      this._trigger('validate');\n\n      return (_whenValid$always$done$fail$always = this.whenValid({ force: force, value: this.value, _refreshed: true }).always(function () {\n        _this10._reflowUI();\n      }).done(function () {\n        _this10._trigger('success');\n      }).fail(function () {\n        _this10._trigger('error');\n      }).always(function () {\n        _this10._trigger('validated');\n      })).pipe.apply(_whenValid$always$done$fail$always, _toConsumableArray(this._pipeAccordingToValidationResult()));\n    },\n\n    hasConstraints: function hasConstraints() {\n      return 0 !== this.constraints.length;\n    },\n\n    // An empty optional field does not need validation\n    needsValidation: function needsValidation(value) {\n      if ('undefined' === typeof value) value = this.getValue();\n\n      // If a field is empty and not required, it is valid\n      // Except if `data-parsley-validate-if-empty` explicitely added, useful for some custom validators\n      if (!value.length && !this._isRequired() && 'undefined' === typeof this.options.validateIfEmpty) return false;\n\n      return true;\n    },\n\n    _isInGroup: function _isInGroup(group) {\n      if ($.isArray(this.options.group)) return -1 !== $.inArray(group, this.options.group);\n      return this.options.group === group;\n    },\n\n    // Just validate field. Do not trigger any event.\n    // Returns `true` iff all constraints pass, `false` if there are failures,\n    // or `null` if the result can not be determined yet (depends on a promise)\n    // See also `whenValid`.\n    isValid: function isValid(options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        Utils__default.warnOnce('Calling isValid on a parsley field without passing arguments as an object is deprecated.');\n\n        var _arguments3 = _slice.call(arguments);\n\n        var force = _arguments3[0];\n        var value = _arguments3[1];\n\n        options = { force: force, value: value };\n      }\n      var promise = this.whenValid(options);\n      if (!promise) // Excluded via `group`\n        return true;\n      return parsley_field__statusMapping[promise.state()];\n    },\n\n    // Just validate field. Do not trigger any event.\n    // @returns a promise that succeeds only when all validations do\n    // or `undefined` if the field is not in the given `group`.\n    // The argument `force` will force validation of empty fields.\n    // If a `value` is given, it will be validated instead of the value of the input.\n    whenValid: function whenValid() {\n      var _this11 = this;\n\n      var _ref10 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var _ref10$force = _ref10.force;\n      var force = _ref10$force === undefined ? false : _ref10$force;\n      var value = _ref10.value;\n      var group = _ref10.group;\n      var _refreshed = _ref10._refreshed;\n\n      // Recompute options and rebind constraints to have latest changes\n      if (!_refreshed) this.refreshConstraints();\n      // do not validate a field if not the same as given validation group\n      if (group && !this._isInGroup(group)) return;\n\n      this.validationResult = true;\n\n      // A field without constraint is valid\n      if (!this.hasConstraints()) return $.when();\n\n      // Value could be passed as argument, needed to add more power to 'field:validate'\n      if ('undefined' === typeof value || null === value) value = this.getValue();\n\n      if (!this.needsValidation(value) && true !== force) return $.when();\n\n      var groupedConstraints = this._getGroupedConstraints();\n      var promises = [];\n      $.each(groupedConstraints, function (_, constraints) {\n        // Process one group of constraints at a time, we validate the constraints\n        // and combine the promises together.\n        var promise = Utils__default.all($.map(constraints, function (constraint) {\n          return _this11._validateConstraint(value, constraint);\n        }));\n        promises.push(promise);\n        if (promise.state() === 'rejected') return false; // Interrupt processing if a group has already failed\n      });\n      return Utils__default.all(promises);\n    },\n\n    // @returns a promise\n    _validateConstraint: function _validateConstraint(value, constraint) {\n      var _this12 = this;\n\n      var result = constraint.validate(value, this);\n      // Map false to a failed promise\n      if (false === result) result = $.Deferred().reject();\n      // Make sure we return a promise and that we record failures\n      return Utils__default.all([result]).fail(function (errorMessage) {\n        if (!(_this12.validationResult instanceof Array)) _this12.validationResult = [];\n        _this12.validationResult.push({\n          assert: constraint,\n          errorMessage: 'string' === typeof errorMessage && errorMessage\n        });\n      });\n    },\n\n    // @returns Parsley field computed value that could be overrided or configured in DOM\n    getValue: function getValue() {\n      var value;\n\n      // Value could be overriden in DOM or with explicit options\n      if ('function' === typeof this.options.value) value = this.options.value(this);else if ('undefined' !== typeof this.options.value) value = this.options.value;else value = this.$element.val();\n\n      // Handle wrong DOM or configurations\n      if ('undefined' === typeof value || null === value) return '';\n\n      return this._handleWhitespace(value);\n    },\n\n    // Reset UI\n    reset: function reset() {\n      this._resetUI();\n      return this._trigger('reset');\n    },\n\n    // Destroy Parsley instance (+ UI)\n    destroy: function destroy() {\n      // Field case: emit destroy event to clean UI and then destroy stored instance\n      this._destroyUI();\n      this.$element.removeData('Parsley');\n      this.$element.removeData('FieldMultiple');\n      this._trigger('destroy');\n    },\n\n    // Actualize options that could have change since previous validation\n    // Re-bind accordingly constraints (could be some new, removed or updated)\n    refreshConstraints: function refreshConstraints() {\n      return this.actualizeOptions()._bindConstraints();\n    },\n\n    /**\n    * Add a new constraint to a field\n    *\n    * @param {String}   name\n    * @param {Mixed}    requirements      optional\n    * @param {Number}   priority          optional\n    * @param {Boolean}  isDomConstraint   optional\n    */\n    addConstraint: function addConstraint(name, requirements, priority, isDomConstraint) {\n\n      if (window.Parsley._validatorRegistry.validators[name]) {\n        var constraint = new Constraint(this, name, requirements, priority, isDomConstraint);\n\n        // if constraint already exist, delete it and push new version\n        if ('undefined' !== this.constraintsByName[constraint.name]) this.removeConstraint(constraint.name);\n\n        this.constraints.push(constraint);\n        this.constraintsByName[constraint.name] = constraint;\n      }\n\n      return this;\n    },\n\n    // Remove a constraint\n    removeConstraint: function removeConstraint(name) {\n      for (var i = 0; i < this.constraints.length; i++) if (name === this.constraints[i].name) {\n        this.constraints.splice(i, 1);\n        break;\n      }\n      delete this.constraintsByName[name];\n      return this;\n    },\n\n    // Update a constraint (Remove + re-add)\n    updateConstraint: function updateConstraint(name, parameters, priority) {\n      return this.removeConstraint(name).addConstraint(name, parameters, priority);\n    },\n\n    // # Internals\n\n    // Internal only.\n    // Bind constraints from config + options + DOM\n    _bindConstraints: function _bindConstraints() {\n      var constraints = [];\n      var constraintsByName = {};\n\n      // clean all existing DOM constraints to only keep javascript user constraints\n      for (var i = 0; i < this.constraints.length; i++) if (false === this.constraints[i].isDomConstraint) {\n        constraints.push(this.constraints[i]);\n        constraintsByName[this.constraints[i].name] = this.constraints[i];\n      }\n\n      this.constraints = constraints;\n      this.constraintsByName = constraintsByName;\n\n      // then re-add Parsley DOM-API constraints\n      for (var name in this.options) this.addConstraint(name, this.options[name], undefined, true);\n\n      // finally, bind special HTML5 constraints\n      return this._bindHtml5Constraints();\n    },\n\n    // Internal only.\n    // Bind specific HTML5 constraints to be HTML5 compliant\n    _bindHtml5Constraints: function _bindHtml5Constraints() {\n      // html5 required\n      if (this.$element.attr('required')) this.addConstraint('required', true, undefined, true);\n\n      // html5 pattern\n      if ('string' === typeof this.$element.attr('pattern')) this.addConstraint('pattern', this.$element.attr('pattern'), undefined, true);\n\n      // range\n      if ('undefined' !== typeof this.$element.attr('min') && 'undefined' !== typeof this.$element.attr('max')) this.addConstraint('range', [this.$element.attr('min'), this.$element.attr('max')], undefined, true);\n\n      // HTML5 min\n      else if ('undefined' !== typeof this.$element.attr('min')) this.addConstraint('min', this.$element.attr('min'), undefined, true);\n\n        // HTML5 max\n        else if ('undefined' !== typeof this.$element.attr('max')) this.addConstraint('max', this.$element.attr('max'), undefined, true);\n\n      // length\n      if ('undefined' !== typeof this.$element.attr('minlength') && 'undefined' !== typeof this.$element.attr('maxlength')) this.addConstraint('length', [this.$element.attr('minlength'), this.$element.attr('maxlength')], undefined, true);\n\n      // HTML5 minlength\n      else if ('undefined' !== typeof this.$element.attr('minlength')) this.addConstraint('minlength', this.$element.attr('minlength'), undefined, true);\n\n        // HTML5 maxlength\n        else if ('undefined' !== typeof this.$element.attr('maxlength')) this.addConstraint('maxlength', this.$element.attr('maxlength'), undefined, true);\n\n      // html5 types\n      var type = this.$element.attr('type');\n\n      if ('undefined' === typeof type) return this;\n\n      // Small special case here for HTML5 number: integer validator if step attribute is undefined or an integer value, number otherwise\n      if ('number' === type) {\n        return this.addConstraint('type', ['number', {\n          step: this.$element.attr('step') || '1',\n          base: this.$element.attr('min') || this.$element.attr('value')\n        }], undefined, true);\n        // Regular other HTML5 supported types\n      } else if (/^(email|url|range|date)$/i.test(type)) {\n          return this.addConstraint('type', type, undefined, true);\n        }\n      return this;\n    },\n\n    // Internal only.\n    // Field is required if have required constraint without `false` value\n    _isRequired: function _isRequired() {\n      if ('undefined' === typeof this.constraintsByName.required) return false;\n\n      return false !== this.constraintsByName.required.requirements;\n    },\n\n    // Internal only.\n    // Shortcut to trigger an event\n    _trigger: function _trigger(eventName) {\n      return this.trigger('field:' + eventName);\n    },\n\n    // Internal only\n    // Handles whitespace in a value\n    // Use `data-parsley-whitespace=\"squish\"` to auto squish input value\n    // Use `data-parsley-whitespace=\"trim\"` to auto trim input value\n    _handleWhitespace: function _handleWhitespace(value) {\n      if (true === this.options.trimValue) Utils__default.warnOnce('data-parsley-trim-value=\"true\" is deprecated, please use data-parsley-whitespace=\"trim\"');\n\n      if ('squish' === this.options.whitespace) value = value.replace(/\\s{2,}/g, ' ');\n\n      if ('trim' === this.options.whitespace || 'squish' === this.options.whitespace || true === this.options.trimValue) value = Utils__default.trimString(value);\n\n      return value;\n    },\n\n    _isDateInput: function _isDateInput() {\n      var c = this.constraintsByName.type;\n      return c && c.requirements === 'date';\n    },\n\n    // Internal only.\n    // Returns the constraints, grouped by descending priority.\n    // The result is thus an array of arrays of constraints.\n    _getGroupedConstraints: function _getGroupedConstraints() {\n      if (false === this.options.priorityEnabled) return [this.constraints];\n\n      var groupedConstraints = [];\n      var index = {};\n\n      // Create array unique of priorities\n      for (var i = 0; i < this.constraints.length; i++) {\n        var p = this.constraints[i].priority;\n        if (!index[p]) groupedConstraints.push(index[p] = []);\n        index[p].push(this.constraints[i]);\n      }\n      // Sort them by priority DESC\n      groupedConstraints.sort(function (a, b) {\n        return b[0].priority - a[0].priority;\n      });\n\n      return groupedConstraints;\n    }\n\n  };\n\n  var parsley_field = Field;\n\n  var Multiple = function Multiple() {\n    this.__class__ = 'FieldMultiple';\n  };\n\n  Multiple.prototype = {\n    // Add new `$element` sibling for multiple field\n    addElement: function addElement($element) {\n      this.$elements.push($element);\n\n      return this;\n    },\n\n    // See `Field.refreshConstraints()`\n    refreshConstraints: function refreshConstraints() {\n      var fieldConstraints;\n\n      this.constraints = [];\n\n      // Select multiple special treatment\n      if (this.$element.is('select')) {\n        this.actualizeOptions()._bindConstraints();\n\n        return this;\n      }\n\n      // Gather all constraints for each input in the multiple group\n      for (var i = 0; i < this.$elements.length; i++) {\n\n        // Check if element have not been dynamically removed since last binding\n        if (!$('html').has(this.$elements[i]).length) {\n          this.$elements.splice(i, 1);\n          continue;\n        }\n\n        fieldConstraints = this.$elements[i].data('FieldMultiple').refreshConstraints().constraints;\n\n        for (var j = 0; j < fieldConstraints.length; j++) this.addConstraint(fieldConstraints[j].name, fieldConstraints[j].requirements, fieldConstraints[j].priority, fieldConstraints[j].isDomConstraint);\n      }\n\n      return this;\n    },\n\n    // See `Field.getValue()`\n    getValue: function getValue() {\n      // Value could be overriden in DOM\n      if ('function' === typeof this.options.value) return this.options.value(this);else if ('undefined' !== typeof this.options.value) return this.options.value;\n\n      // Radio input case\n      if (this.$element.is('input[type=radio]')) return this._findRelated().filter(':checked').val() || '';\n\n      // checkbox input case\n      if (this.$element.is('input[type=checkbox]')) {\n        var values = [];\n\n        this._findRelated().filter(':checked').each(function () {\n          values.push($(this).val());\n        });\n\n        return values;\n      }\n\n      // Select multiple case\n      if (this.$element.is('select') && null === this.$element.val()) return [];\n\n      // Default case that should never happen\n      return this.$element.val();\n    },\n\n    _init: function _init() {\n      this.$elements = [this.$element];\n\n      return this;\n    }\n  };\n\n  var Factory = function Factory(element, options, parsleyFormInstance) {\n    this.$element = $(element);\n\n    // If the element has already been bound, returns its saved Parsley instance\n    var savedparsleyFormInstance = this.$element.data('Parsley');\n    if (savedparsleyFormInstance) {\n\n      // If the saved instance has been bound without a Form parent and there is one given in this call, add it\n      if ('undefined' !== typeof parsleyFormInstance && savedparsleyFormInstance.parent === window.Parsley) {\n        savedparsleyFormInstance.parent = parsleyFormInstance;\n        savedparsleyFormInstance._resetOptions(savedparsleyFormInstance.options);\n      }\n\n      if ('object' === typeof options) {\n        $.extend(savedparsleyFormInstance.options, options);\n      }\n\n      return savedparsleyFormInstance;\n    }\n\n    // Parsley must be instantiated with a DOM element or jQuery $element\n    if (!this.$element.length) throw new Error('You must bind Parsley on an existing element.');\n\n    if ('undefined' !== typeof parsleyFormInstance && 'Form' !== parsleyFormInstance.__class__) throw new Error('Parent instance must be a Form instance');\n\n    this.parent = parsleyFormInstance || window.Parsley;\n    return this.init(options);\n  };\n\n  Factory.prototype = {\n    init: function init(options) {\n      this.__class__ = 'Parsley';\n      this.__version__ = '2.7.0';\n      this.__id__ = Utils__default.generateID();\n\n      // Pre-compute options\n      this._resetOptions(options);\n\n      // A Form instance is obviously a `<form>` element but also every node that is not an input and has the `data-parsley-validate` attribute\n      if (this.$element.is('form') || Utils__default.checkAttr(this.$element, this.options.namespace, 'validate') && !this.$element.is(this.options.inputs)) return this.bind('parsleyForm');\n\n      // Every other element is bound as a `Field` or `FieldMultiple`\n      return this.isMultiple() ? this.handleMultiple() : this.bind('parsleyField');\n    },\n\n    isMultiple: function isMultiple() {\n      return this.$element.is('input[type=radio], input[type=checkbox]') || this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple');\n    },\n\n    // Multiples fields are a real nightmare :(\n    // Maybe some refactoring would be appreciated here...\n    handleMultiple: function handleMultiple() {\n      var _this13 = this;\n\n      var name;\n      var multiple;\n      var parsleyMultipleInstance;\n\n      // Handle multiple name\n      if (this.options.multiple) ; // We already have our 'multiple' identifier\n      else if ('undefined' !== typeof this.$element.attr('name') && this.$element.attr('name').length) this.options.multiple = name = this.$element.attr('name');else if ('undefined' !== typeof this.$element.attr('id') && this.$element.attr('id').length) this.options.multiple = this.$element.attr('id');\n\n      // Special select multiple input\n      if (this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple')) {\n        this.options.multiple = this.options.multiple || this.__id__;\n        return this.bind('parsleyFieldMultiple');\n\n        // Else for radio / checkboxes, we need a `name` or `data-parsley-multiple` to properly bind it\n      } else if (!this.options.multiple) {\n          Utils__default.warn('To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.', this.$element);\n          return this;\n        }\n\n      // Remove special chars\n      this.options.multiple = this.options.multiple.replace(/(:|\\.|\\[|\\]|\\{|\\}|\\$)/g, '');\n\n      // Add proper `data-parsley-multiple` to siblings if we have a valid multiple name\n      if ('undefined' !== typeof name) {\n        $('input[name=\"' + name + '\"]').each(function (i, input) {\n          if ($(input).is('input[type=radio], input[type=checkbox]')) $(input).attr(_this13.options.namespace + 'multiple', _this13.options.multiple);\n        });\n      }\n\n      // Check here if we don't already have a related multiple instance saved\n      var $previouslyRelated = this._findRelated();\n      for (var i = 0; i < $previouslyRelated.length; i++) {\n        parsleyMultipleInstance = $($previouslyRelated.get(i)).data('Parsley');\n        if ('undefined' !== typeof parsleyMultipleInstance) {\n\n          if (!this.$element.data('FieldMultiple')) {\n            parsleyMultipleInstance.addElement(this.$element);\n          }\n\n          break;\n        }\n      }\n\n      // Create a secret Field instance for every multiple field. It will be stored in `data('FieldMultiple')`\n      // And will be useful later to access classic `Field` stuff while being in a `FieldMultiple` instance\n      this.bind('parsleyField', true);\n\n      return parsleyMultipleInstance || this.bind('parsleyFieldMultiple');\n    },\n\n    // Return proper `Form`, `Field` or `FieldMultiple`\n    bind: function bind(type, doNotStore) {\n      var parsleyInstance;\n\n      switch (type) {\n        case 'parsleyForm':\n          parsleyInstance = $.extend(new Form(this.$element, this.domOptions, this.options), new Base(), window.ParsleyExtend)._bindFields();\n          break;\n        case 'parsleyField':\n          parsleyInstance = $.extend(new parsley_field(this.$element, this.domOptions, this.options, this.parent), new Base(), window.ParsleyExtend);\n          break;\n        case 'parsleyFieldMultiple':\n          parsleyInstance = $.extend(new parsley_field(this.$element, this.domOptions, this.options, this.parent), new Multiple(), new Base(), window.ParsleyExtend)._init();\n          break;\n        default:\n          throw new Error(type + 'is not a supported Parsley type');\n      }\n\n      if (this.options.multiple) Utils__default.setAttr(this.$element, this.options.namespace, 'multiple', this.options.multiple);\n\n      if ('undefined' !== typeof doNotStore) {\n        this.$element.data('FieldMultiple', parsleyInstance);\n\n        return parsleyInstance;\n      }\n\n      // Store the freshly bound instance in a DOM element for later access using jQuery `data()`\n      this.$element.data('Parsley', parsleyInstance);\n\n      // Tell the world we have a new Form or Field instance!\n      parsleyInstance._actualizeTriggers();\n      parsleyInstance._trigger('init');\n\n      return parsleyInstance;\n    }\n  };\n\n  var vernums = $.fn.jquery.split('.');\n  if (parseInt(vernums[0]) <= 1 && parseInt(vernums[1]) < 8) {\n    throw \"The loaded version of jQuery is too old. Please upgrade to 1.8.x or better.\";\n  }\n  if (!vernums.forEach) {\n    Utils__default.warn('Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim');\n  }\n  // Inherit `on`, `off` & `trigger` to Parsley:\n  var Parsley = $.extend(new Base(), {\n    $element: $(document),\n    actualizeOptions: null,\n    _resetOptions: null,\n    Factory: Factory,\n    version: '2.7.0'\n  });\n\n  // Supplement Field and Form with Base\n  // This way, the constructors will have access to those methods\n  $.extend(parsley_field.prototype, UI.Field, Base.prototype);\n  $.extend(Form.prototype, UI.Form, Base.prototype);\n  // Inherit actualizeOptions and _resetOptions:\n  $.extend(Factory.prototype, Base.prototype);\n\n  // ### jQuery API\n  // `$('.elem').parsley(options)` or `$('.elem').psly(options)`\n  $.fn.parsley = $.fn.psly = function (options) {\n    if (this.length > 1) {\n      var instances = [];\n\n      this.each(function () {\n        instances.push($(this).parsley(options));\n      });\n\n      return instances;\n    }\n\n    // Return undefined if applied to non existing DOM element\n    if (!$(this).length) {\n      Utils__default.warn('You must bind Parsley on an existing element.');\n\n      return;\n    }\n\n    return new Factory(this, options);\n  };\n\n  // ### Field and Form extension\n  // Ensure the extension is now defined if it wasn't previously\n  if ('undefined' === typeof window.ParsleyExtend) window.ParsleyExtend = {};\n\n  // ### Parsley config\n  // Inherit from ParsleyDefault, and copy over any existing values\n  Parsley.options = $.extend(Utils__default.objectCreate(Defaults), window.ParsleyConfig);\n  window.ParsleyConfig = Parsley.options; // Old way of accessing global options\n\n  // ### Globals\n  window.Parsley = window.psly = Parsley;\n  Parsley.Utils = Utils__default;\n  window.ParsleyUtils = {};\n  $.each(Utils__default, function (key, value) {\n    if ('function' === typeof value) {\n      window.ParsleyUtils[key] = function () {\n        Utils__default.warnOnce('Accessing `window.ParsleyUtils` is deprecated. Use `window.Parsley.Utils` instead.');\n        return Utils__default[key].apply(Utils__default, arguments);\n      };\n    }\n  });\n\n  // ### Define methods that forward to the registry, and deprecate all access except through window.Parsley\n  var registry = window.Parsley._validatorRegistry = new ValidatorRegistry(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);\n  window.ParsleyValidator = {};\n  $.each('setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator'.split(' '), function (i, method) {\n    window.Parsley[method] = $.proxy(registry, method);\n    window.ParsleyValidator[method] = function () {\n      var _window$Parsley;\n\n      Utils__default.warnOnce('Accessing the method \\'' + method + '\\' through Validator is deprecated. Simply call \\'window.Parsley.' + method + '(...)\\'');\n      return (_window$Parsley = window.Parsley)[method].apply(_window$Parsley, arguments);\n    };\n  });\n\n  // ### UI\n  // Deprecated global object\n  window.Parsley.UI = UI;\n  window.ParsleyUI = {\n    removeError: function removeError(instance, name, doNotUpdateClass) {\n      var updateClass = true !== doNotUpdateClass;\n      Utils__default.warnOnce('Accessing UI is deprecated. Call \\'removeError\\' on the instance directly. Please comment in issue 1073 as to your need to call this method.');\n      return instance.removeError(name, { updateClass: updateClass });\n    },\n    getErrorsMessages: function getErrorsMessages(instance) {\n      Utils__default.warnOnce('Accessing UI is deprecated. Call \\'getErrorsMessages\\' on the instance directly.');\n      return instance.getErrorsMessages();\n    }\n  };\n  $.each('addError updateError'.split(' '), function (i, method) {\n    window.ParsleyUI[method] = function (instance, name, message, assert, doNotUpdateClass) {\n      var updateClass = true !== doNotUpdateClass;\n      Utils__default.warnOnce('Accessing UI is deprecated. Call \\'' + method + '\\' on the instance directly. Please comment in issue 1073 as to your need to call this method.');\n      return instance[method](name, { message: message, assert: assert, updateClass: updateClass });\n    };\n  });\n\n  // ### PARSLEY auto-binding\n  // Prevent it by setting `ParsleyConfig.autoBind` to `false`\n  if (false !== window.ParsleyConfig.autoBind) {\n    $(function () {\n      // Works only on `data-parsley-validate`.\n      if ($('[data-parsley-validate]').length) $('[data-parsley-validate]').parsley();\n    });\n  }\n\n  var o = $({});\n  var deprecated = function deprecated() {\n    Utils__default.warnOnce(\"Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley\");\n  };\n\n  // Returns an event handler that calls `fn` with the arguments it expects\n  function adapt(fn, context) {\n    // Store to allow unbinding\n    if (!fn.parsleyAdaptedCallback) {\n      fn.parsleyAdaptedCallback = function () {\n        var args = Array.prototype.slice.call(arguments, 0);\n        args.unshift(this);\n        fn.apply(context || o, args);\n      };\n    }\n    return fn.parsleyAdaptedCallback;\n  }\n\n  var eventPrefix = 'parsley:';\n  // Converts 'parsley:form:validate' into 'form:validate'\n  function eventName(name) {\n    if (name.lastIndexOf(eventPrefix, 0) === 0) return name.substr(eventPrefix.length);\n    return name;\n  }\n\n  // $.listen is deprecated. Use Parsley.on instead.\n  $.listen = function (name, callback) {\n    var context;\n    deprecated();\n    if ('object' === typeof arguments[1] && 'function' === typeof arguments[2]) {\n      context = arguments[1];\n      callback = arguments[2];\n    }\n\n    if ('function' !== typeof callback) throw new Error('Wrong parameters');\n\n    window.Parsley.on(eventName(name), adapt(callback, context));\n  };\n\n  $.listenTo = function (instance, name, fn) {\n    deprecated();\n    if (!(instance instanceof parsley_field) && !(instance instanceof Form)) throw new Error('Must give Parsley instance');\n\n    if ('string' !== typeof name || 'function' !== typeof fn) throw new Error('Wrong parameters');\n\n    instance.on(eventName(name), adapt(fn));\n  };\n\n  $.unsubscribe = function (name, fn) {\n    deprecated();\n    if ('string' !== typeof name || 'function' !== typeof fn) throw new Error('Wrong arguments');\n    window.Parsley.off(eventName(name), fn.parsleyAdaptedCallback);\n  };\n\n  $.unsubscribeTo = function (instance, name) {\n    deprecated();\n    if (!(instance instanceof parsley_field) && !(instance instanceof Form)) throw new Error('Must give Parsley instance');\n    instance.off(eventName(name));\n  };\n\n  $.unsubscribeAll = function (name) {\n    deprecated();\n    window.Parsley.off(eventName(name));\n    $('form,input,textarea,select').each(function () {\n      var instance = $(this).data('Parsley');\n      if (instance) {\n        instance.off(eventName(name));\n      }\n    });\n  };\n\n  // $.emit is deprecated. Use jQuery events instead.\n  $.emit = function (name, instance) {\n    var _instance;\n\n    deprecated();\n    var instanceGiven = instance instanceof parsley_field || instance instanceof Form;\n    var args = Array.prototype.slice.call(arguments, instanceGiven ? 2 : 1);\n    args.unshift(eventName(name));\n    if (!instanceGiven) {\n      instance = window.Parsley;\n    }\n    (_instance = instance).trigger.apply(_instance, _toConsumableArray(args));\n  };\n\n  var pubsub = {};\n\n  $.extend(true, Parsley, {\n    asyncValidators: {\n      'default': {\n        fn: function fn(xhr) {\n          // By default, only status 2xx are deemed successful.\n          // Note: we use status instead of state() because responses with status 200\n          // but invalid messages (e.g. an empty body for content type set to JSON) will\n          // result in state() === 'rejected'.\n          return xhr.status >= 200 && xhr.status < 300;\n        },\n        url: false\n      },\n      reverse: {\n        fn: function fn(xhr) {\n          // If reverse option is set, a failing ajax request is considered successful\n          return xhr.status < 200 || xhr.status >= 300;\n        },\n        url: false\n      }\n    },\n\n    addAsyncValidator: function addAsyncValidator(name, fn, url, options) {\n      Parsley.asyncValidators[name] = {\n        fn: fn,\n        url: url || false,\n        options: options || {}\n      };\n\n      return this;\n    }\n\n  });\n\n  Parsley.addValidator('remote', {\n    requirementType: {\n      '': 'string',\n      'validator': 'string',\n      'reverse': 'boolean',\n      'options': 'object'\n    },\n\n    validateString: function validateString(value, url, options, instance) {\n      var data = {};\n      var ajaxOptions;\n      var csr;\n      var validator = options.validator || (true === options.reverse ? 'reverse' : 'default');\n\n      if ('undefined' === typeof Parsley.asyncValidators[validator]) throw new Error('Calling an undefined async validator: `' + validator + '`');\n\n      url = Parsley.asyncValidators[validator].url || url;\n\n      // Fill current value\n      if (url.indexOf('{value}') > -1) {\n        url = url.replace('{value}', encodeURIComponent(value));\n      } else {\n        data[instance.$element.attr('name') || instance.$element.attr('id')] = value;\n      }\n\n      // Merge options passed in from the function with the ones in the attribute\n      var remoteOptions = $.extend(true, options.options || {}, Parsley.asyncValidators[validator].options);\n\n      // All `$.ajax(options)` could be overridden or extended directly from DOM in `data-parsley-remote-options`\n      ajaxOptions = $.extend(true, {}, {\n        url: url,\n        data: data,\n        type: 'GET'\n      }, remoteOptions);\n\n      // Generate store key based on ajax options\n      instance.trigger('field:ajaxoptions', instance, ajaxOptions);\n\n      csr = $.param(ajaxOptions);\n\n      // Initialise querry cache\n      if ('undefined' === typeof Parsley._remoteCache) Parsley._remoteCache = {};\n\n      // Try to retrieve stored xhr\n      var xhr = Parsley._remoteCache[csr] = Parsley._remoteCache[csr] || $.ajax(ajaxOptions);\n\n      var handleXhr = function handleXhr() {\n        var result = Parsley.asyncValidators[validator].fn.call(instance, xhr, url, options);\n        if (!result) // Map falsy results to rejected promise\n          result = $.Deferred().reject();\n        return $.when(result);\n      };\n\n      return xhr.then(handleXhr, handleXhr);\n    },\n\n    priority: -1\n  });\n\n  Parsley.on('form:submit', function () {\n    Parsley._remoteCache = {};\n  });\n\n  window.ParsleyExtend.addAsyncValidator = function () {\n    Utils.warnOnce('Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`');\n    return Parsley.addAsyncValidator.apply(Parsley, arguments);\n  };\n\n  // This is included with the Parsley library itself,\n  // thus there is no use in adding it to your project.\n  Parsley.addMessages('en', {\n    defaultMessage: \"This value seems to be invalid.\",\n    type: {\n      email: \"This value should be a valid email.\",\n      url: \"This value should be a valid url.\",\n      number: \"This value should be a valid number.\",\n      integer: \"This value should be a valid integer.\",\n      digits: \"This value should be digits.\",\n      alphanum: \"This value should be alphanumeric.\"\n    },\n    notblank: \"This value should not be blank.\",\n    required: \"This value is required.\",\n    pattern: \"This value seems to be invalid.\",\n    min: \"This value should be greater than or equal to %s.\",\n    max: \"This value should be lower than or equal to %s.\",\n    range: \"This value should be between %s and %s.\",\n    minlength: \"This value is too short. It should have %s characters or more.\",\n    maxlength: \"This value is too long. It should have %s characters or fewer.\",\n    length: \"This value length is invalid. It should be between %s and %s characters long.\",\n    mincheck: \"You must select at least %s choices.\",\n    maxcheck: \"You must select %s choices or fewer.\",\n    check: \"You must select between %s and %s choices.\",\n    equalto: \"This value should be the same.\"\n  });\n\n  Parsley.setLocale('en');\n\n  /**\n   * inputevent - Alleviate browser bugs for input events\n   * https://github.com/marcandre/inputevent\n   * @version v0.0.3 - (built Thu, Apr 14th 2016, 5:58 pm)\n   * @author Marc-Andre Lafortune <github@marc-andre.ca>\n   * @license MIT\n   */\n\n  function InputEvent() {\n    var _this14 = this;\n\n    var globals = window || global;\n\n    // Slightly odd way construct our object. This way methods are force bound.\n    // Used to test for duplicate library.\n    $.extend(this, {\n\n      // For browsers that do not support isTrusted, assumes event is native.\n      isNativeEvent: function isNativeEvent(evt) {\n        return evt.originalEvent && evt.originalEvent.isTrusted !== false;\n      },\n\n      fakeInputEvent: function fakeInputEvent(evt) {\n        if (_this14.isNativeEvent(evt)) {\n          $(evt.target).trigger('input');\n        }\n      },\n\n      misbehaves: function misbehaves(evt) {\n        if (_this14.isNativeEvent(evt)) {\n          _this14.behavesOk(evt);\n          $(document).on('change.inputevent', evt.data.selector, _this14.fakeInputEvent);\n          _this14.fakeInputEvent(evt);\n        }\n      },\n\n      behavesOk: function behavesOk(evt) {\n        if (_this14.isNativeEvent(evt)) {\n          $(document) // Simply unbinds the testing handler\n          .off('input.inputevent', evt.data.selector, _this14.behavesOk).off('change.inputevent', evt.data.selector, _this14.misbehaves);\n        }\n      },\n\n      // Bind the testing handlers\n      install: function install() {\n        if (globals.inputEventPatched) {\n          return;\n        }\n        globals.inputEventPatched = '0.0.3';\n        var _arr = ['select', 'input[type=\"checkbox\"]', 'input[type=\"radio\"]', 'input[type=\"file\"]'];\n        for (var _i = 0; _i < _arr.length; _i++) {\n          var selector = _arr[_i];\n          $(document).on('input.inputevent', selector, { selector: selector }, _this14.behavesOk).on('change.inputevent', selector, { selector: selector }, _this14.misbehaves);\n        }\n      },\n\n      uninstall: function uninstall() {\n        delete globals.inputEventPatched;\n        $(document).off('.inputevent');\n      }\n\n    });\n  };\n\n  var inputevent = new InputEvent();\n\n  inputevent.install();\n\n  var parsley = Parsley;\n\n  return parsley;\n});\n//# sourceMappingURL=parsley.js.map\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/gulpfile.babel.js":"import gulp  from 'gulp';\nimport loadPlugins from 'gulp-load-plugins';\nimport del  from 'del';\nimport glob  from 'glob';\nimport path  from 'path';\nimport isparta  from 'isparta';\nimport babelify  from 'babelify';\nimport watchify  from 'watchify';\nimport buffer  from 'vinyl-buffer';\nimport esperanto  from 'esperanto';\nimport browserify  from 'browserify';\nimport runSequence  from 'run-sequence';\nimport source  from 'vinyl-source-stream';\nimport fs  from 'fs';\nimport moment  from 'moment';\nimport docco  from 'docco';\nimport {spawn} from 'child_process';\nimport manifest  from './package.json';\n\n// Load all of our Gulp plugins\nconst $ = loadPlugins();\n\n// Gather the library data from `package.json`\nconst config = manifest.babelBoilerplateOptions;\nconst mainFile = manifest.main;\nconst destinationFolder = path.dirname(mainFile);\nconst exportFileName = path.basename(mainFile, path.extname(mainFile));\n\n// Remove a directory\nfunction _clean(dir, done) {\n  del([dir], done);\n}\n\nfunction cleanDist(done) {\n  _clean(destinationFolder, done)\n}\n\nfunction cleanTmp() {\n  _clean('tmp', done)\n}\n\n// Send a notification when JSCS fails,\n// so that you know your changes didn't build\nfunction _jscsNotify(file) {\n  if (!file.jscs) { return; }\n  return file.jscs.success ? false : 'JSCS failed';\n}\n\n// Lint a set of files\nfunction lint(files) {\n  return gulp.src(files)\n    .pipe($.plumber())\n    .pipe($.eslint())\n    .pipe($.eslint.format())\n    .pipe($.eslint.failOnError())\n    .pipe($.jscs())\n    .pipe($.notify(_jscsNotify));\n}\n\nfunction lintSrc() {\n  return lint('src/**/*.js');\n}\n\nfunction lintTest() {\n  return lint('test/**/*.js');\n}\n\nfunction build(done) {\n  esperanto.bundle({\n    base: 'src',\n    entry: config.entryFileName,\n  }).then(bundle => {\n    const res = bundle.toUmd({\n      // Don't worry about the fact that the source map is inlined at this step.\n      // `gulp-sourcemaps`, which comes next, will externalize them.\n      sourceMap: 'inline',\n      name: config.mainVarName\n    });\n    const head = fs.readFileSync('src/header.js', 'utf8');\n\n    $.file(exportFileName + '.js', res.code, { src: true })\n      .pipe($.plumber())\n      .pipe($.replace('@@version', manifest.version))\n      .pipe($.sourcemaps.init({ loadMaps: true }))\n      .pipe($.babel())\n      .pipe($.header(head, {pkg: manifest, now: moment()}))\n      .pipe($.replace('global.$', 'global.jQuery')) // Babel bases itself on the variable name we use. Use jQuery for noconflict users.\n      .pipe($.sourcemaps.write('./'))\n      .pipe(gulp.dest(destinationFolder))\n      .pipe($.filter(['*', '!**/*.js.map']))\n      .pipe($.rename(exportFileName + '.min.js'))\n      .pipe($.sourcemaps.init({ loadMaps: true }))\n      .pipe($.uglify({preserveComments: 'license'}))\n      .pipe($.sourcemaps.write('./'))\n      .pipe(gulp.dest(destinationFolder))\n      .on('end', done);\n  })\n  .catch(done);\n}\n\nfunction buildDoc(done) {\n  var dest = 'doc/annotated-source/';\n  var sources = glob.sync('src/parsley/*.js');\n  del.sync([dest + '*']);\n  docco.document({\n    layout: 'parallel',\n    output: dest,\n    args: sources\n  }, function() {\n      gulp.src(dest + '*.html', { base: \"./\" })\n      .pipe($.replace('<div id=\"jump_page\">', '<div id=\"jump_page\"><a class=\"source\" href=\"../index.html\"><<< back to documentation</a>'))\n      .pipe($.replace('</body>', '<script type=\"text/javascript\">var _gaq=_gaq||[];_gaq.push([\"_setAccount\",\"UA-37229467-1\"]);_gaq.push([\"_trackPageview\"]);(function(){var e=document.createElement(\"script\");e.type=\"text/javascript\";e.async=true;e.src=(\"https:\"==document.location.protocol?\"https://ssl\":\"http://www\")+\".google-analytics.com/ga.js\";var t=document.getElementsByTagName(\"script\")[0];t.parentNode.insertBefore(e,t)})();</script></body>'))\n      .pipe(gulp.dest('.'))\n      .on('end', done);\n  });\n}\n\nfunction copyI18n(done) {\n  gulp.src(['src/i18n/*.js'])\n    .pipe($.replace(\"import Parsley from '../parsley';\", \"// Load this after Parsley\"))  // Quick hack\n    .pipe($.replace(\"import Parsley from '../parsley/main';\", \"\"))  // en uses special import\n    .pipe(gulp.dest('dist/i18n/'))\n    .on('end', done);\n}\n\nfunction writeVersion() {\n  return gulp.src(['index.html', 'doc/download.html', 'README.md'], { base: \"./\" })\n    .pipe($.replace(/class=\"parsley-version\">[^<]*</, `class=\"parsley-version\">v${manifest.version}<`))\n    .pipe($.replace(/releases\\/tag\\/[^\"]*/, `releases/tag/${manifest.version}`))\n    .pipe($.replace(/## Version\\n\\n\\S+\\n\\n/, `## Version\\n\\n${manifest.version}\\n\\n`))\n    .pipe(gulp.dest('.'))\n}\n\nfunction _runBrowserifyBundle(bundler, dest) {\n  return bundler.bundle()\n    .on('error', err => {\n      console.log(err.message);\n      this.emit('end');\n    })\n    .pipe($.plumber())\n    .pipe(source(dest || './tmp/__spec-build.js'))\n    .pipe(buffer())\n    .pipe(gulp.dest(''))\n    .pipe($.livereload());\n}\n\nfunction browserifyBundler() {\n  // Our browserify bundle is made up of our unit tests, which\n  // should individually load up pieces of our application.\n  // We also include the browserify setup file.\n  const testFiles = glob.sync('./test/unit/**/*.js');\n  const allFiles = ['./test/setup/browserify.js'].concat(testFiles);\n\n  // Create our bundler, passing in the arguments required for watchify\n  watchify.args.debug = true;\n  const bundler = browserify(allFiles, watchify.args);\n\n  // Set up Babelify so that ES6 works in the tests\n  bundler.transform(babelify.configure({\n    sourceMapRelative: __dirname + '/src'\n  }));\n\n  return bundler;\n}\n\n// Build the unit test suite for running tests\n// in the browser\nfunction _browserifyBundle() {\n  let bundler = browserifyBundler();\n  // Watch the bundler, and re-bundle it whenever files change\n  bundler = watchify(bundler);\n  bundler.on('update', () => _runBrowserifyBundle(bundler));\n\n  return _runBrowserifyBundle(bundler);\n}\n\nfunction buildDocTest() {\n  return _runBrowserifyBundle(browserifyBundler(), './doc/assets/spec-build.js');\n}\n\nfunction _mocha() {\n  return gulp.src(['test/setup/node.js', 'test/unit/**/*.js'], {read: false})\n    .pipe($.mocha({reporter: 'dot', globals: config.mochaGlobals}));\n}\n\nfunction _registerBabel() {\n  require('babel-core/register');\n}\n\nfunction test() {\n  _registerBabel();\n  return _mocha();\n}\n\nfunction coverage(done) {\n  _registerBabel();\n  gulp.src([exportFileName + '.js'])\n    .pipe($.istanbul({ instrumenter: isparta.Instrumenter }))\n    .pipe($.istanbul.hookRequire())\n    .on('finish', () => {\n      return test()\n        .pipe($.istanbul.writeReports())\n        .on('end', done);\n    });\n}\n\n// These are JS files that should be watched by Gulp. When running tests in the browser,\n// watchify is used instead, so these aren't included.\nconst jsWatchFiles = ['src/**/*', 'test/**/*'];\n// These are files other than JS files which are to be watched. They are always watched.\nconst otherWatchFiles = ['package.json', '**/.eslintrc', '.jscsrc'];\n\n// Run the headless unit tests as you make changes.\nfunction watch() {\n  const watchFiles = jsWatchFiles.concat(otherWatchFiles);\n  gulp.watch(watchFiles, ['test']);\n}\n\nfunction testBrowser() {\n  // Ensure that linting occurs before browserify runs. This prevents\n  // the build from breaking due to poorly formatted code.\n  runSequence(['lint-src', 'lint-test'], () => {\n    _browserifyBundle();\n    $.livereload.listen({port: 35729, host: 'localhost', start: true});\n    gulp.watch(otherWatchFiles, ['lint-src', 'lint-test']);\n  });\n}\n\nfunction gitClean() {\n  $.git.status({args : '--porcelain'}, (err, stdout) => {\n    if (err) throw err;\n    if (/^ ?M/.test(stdout)) throw 'You have uncommitted changes!'\n  });\n}\n\nfunction npmPublish(done) {\n  spawn('npm', ['publish'], { stdio: 'inherit' }).on('close', done);\n}\n\nfunction gitPush() {\n  $.git.push('origin', 'master', {args: '--follow-tags'}, err => { if (err) throw err });\n}\n\nfunction gitPushPages() {\n  $.git.push('origin', 'master:gh-pages', err => { if (err) throw err });\n}\n\nfunction gitTag() {\n  $.git.tag(manifest.version, '', {quiet: false}, err => { if (err) throw err });\n}\n\ngulp.task('release-git-clean', gitClean);\ngulp.task('release-npm-publish', npmPublish);\ngulp.task('release-git-push', gitPush);\ngulp.task('release-git-push-pages', gitPushPages);\ngulp.task('release-git-tag', gitTag);\n\ngulp.task('release', () => {\n  runSequence('release-git-clean', 'release-git-tag', 'release-git-push', 'release-git-push-pages', 'release-npm-publish');\n});\n// Remove the built files\ngulp.task('clean', cleanDist);\n\n// Remove our temporary files\ngulp.task('clean-tmp', cleanTmp);\n\n// Lint our source code\ngulp.task('lint-src', lintSrc);\n\n// Lint our test code\ngulp.task('lint-test', lintTest);\n\n// Build two versions of the library\ngulp.task('build-src', ['lint-src', 'clean', 'build-i18n'], build);\n\n// Build the i18n translations\ngulp.task('build-i18n', ['clean'], copyI18n);\n\n// Build the annotated documentation\ngulp.task('build-doc', buildDoc);\n\n// Build the annotated documentation\ngulp.task('build-doc-test', buildDocTest);\n\ngulp.task('write-version', writeVersion);\n\ngulp.task('build', ['build-src', 'build-i18n', 'build-doc', 'build-doc-test', 'write-version']);\n\n// Lint and run our tests\ngulp.task('test', ['lint-src', 'lint-test'], test);\n\n// Set up coverage and run tests\ngulp.task('coverage', ['lint-src', 'lint-test'], coverage);\n\n// Set up a livereload environment for our spec runner `test/runner.html`\ngulp.task('test-browser', testBrowser);\n\n// Run the headless unit tests as you make changes.\ngulp.task('watch', watch);\n\n// An alias of test\ngulp.task('default', ['test']);\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/header.js":"/*!\n* Parsley.js\n* Version <%= pkg.version %> - built <%= now.format('ddd, MMM Do YYYY, h:mm a') %>\n* http://parsleyjs.org\n* Guillaume Potier - <guillaume@wisembly.com>\n* Marc-Andre Lafortune - <petroselinum@marc-andre.ca>\n* MIT Licensed\n*/\n\n// The source code below is generated by babel as\n// Parsley is written in ECMAScript 6\n//\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/parsley.js":"import $ from 'jquery';\nimport Parsley from './parsley/main';\nimport './parsley/pubsub';\nimport './parsley/remote';\nimport './i18n/en';\nimport inputevent from './vendor/inputevent';\n\ninputevent.install();\n\nexport default Parsley;\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/al.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley/main';\n\nParsley.addMessages('al', {\n  defaultMessage: \"Kjo vlerë është invalide.\",\n  type: {\n    email:        \"Kjo vlerë duhet të ketë formë valide të një email adrese.\",\n    url:          \"Kjo vlerë duhet të ketë formë valide të një URL-je.\",\n    number:       \"Kjo vlerë duhet të jetë numërike.\",\n    integer:      \"Kjo vlerë duhet të jetë numër i plotë.\",\n    digits:       \"Kjo vlerë duhet të jetë shifër.\",\n    alphanum:     \"Kjo vlerë duhet të jetë alfanumerike.\"\n  },\n  notblank:       \"Kjo vlerë nuk duhet të jetë e zbrazët.\",\n  required:       \"Kjo vlerë kërkohet domosdosmërisht.\",\n  pattern:        \"Kjo vlerë është invalide.\",\n  min:            \"Kjo vlerë duhet të jetë më e madhe ose e barabartë me %s.\",\n  max:            \"Kjo vlerë duhet të jetë më e vogël ose e barabartë me %s.\",\n  range:          \"Kjo vlerë duhet të jetë në mes të %s dhe %s.\",\n  minlength:      \"Kjo vlerë është shum e shkurtë. Ajo duhet të ketë %s apo më shum shkronja.\",\n  maxlength:      \"Kjo vlerë është shum e gjatë. Ajo duhet të ketë %s apo më pak shkronja\",\n  length:         \"Gjatësia e kësaj vlere është invalide. Ajo duhet të jetë në mes të %s dhe %s shkronjash.\",\n  mincheck:       \"Ju duhet të zgjedhni së paku %s zgjedhje.\",\n  maxcheck:       \"Ju duhet të zgjedhni %s ose më pak zgjedhje.\",\n  check:          \"Ju duhet të zgjedhni në mes të %s dhe %s zgjedhjeve.\",\n  equalto:        \"Kjo vlerë duhet të jetë e njejtë.\"\n});\n\nParsley.setLocale('al');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/ar.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('ar', {\n  defaultMessage: \"تأكد من صحة القيمة المدخل\",\n  type: {\n    email:        \"تأكد من إدخال بريد الكتروني صحيح\",\n    url:          \"تأكد من إدخال رابط صحيح\",\n    number:       \"تأكد من إدخال رقم\",\n    integer:      \"تأكد من إدخال عدد صحيح بدون كسور\",\n    digits:       \"تأكد من إدخال رقم\",\n    alphanum:     \"تأكد من إدخال حروف وأرقام فقط\"\n  },\n  notblank:       \"تأكد من تعبئة الحقل\",\n  required:       \"هذا الحقل مطلوب\",\n  pattern:        \"القيمة المدخلة غير صحيحة\",\n  min:            \"القيمة المدخلة يجب أن تكون أكبر من %s.\",\n  max:            \"القيمة المدخلة يجب أن تكون أصغر من %s.\",\n  range:          \"القيمة المدخلة يجب أن تكون بين %s و %s.\",\n  minlength:      \"القيمة المدخلة قصيرة جداً . تأكد من إدخال %s حرف أو أكثر\",\n  maxlength:      \"القيمة المدخلة طويلة . تأكد من إدخال %s حرف أو أقل\",\n  length:         \"القيمة المدخلة غير صحيحة. تأكد من إدخال بين  %s و %s خانة\",\n  mincheck:       \"يجب اختيار %s خيار على الأقل.\",\n  maxcheck:       \"يجب اختيار%s خيار أو أقل\",\n  check:          \"يجب اختيار بين %s و %s خيار.\",\n  equalto:        \"تأكد من تطابق القيمتين المدخلة.\"\n});\n\nParsley.setLocale('ar');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/bg.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('bg', {\n  defaultMessage: \"Невалидна стойност.\",\n  type: {\n    email:        \"Невалиден имейл адрес.\",\n    url:          \"Невалиден URL адрес.\",\n    number:       \"Невалиден номер.\",\n    integer:      \"Невалиден номер.\",\n    digits:       \"Невалидни цифри.\",\n    alphanum:     \"Стойността трябва да садържа само букви или цифри.\"\n  },\n  notblank:       \"Полето е задължително.\",\n  required:       \"Полето е задължително.\",\n  pattern:        \"Невалидна стойност.\",\n  min:            \"Стойността трябва да бъде по-голяма или равна на %s.\",\n  max:            \"Стойността трябва да бъде по-малка или равна на %s.\",\n  range:          \"Стойността трябва да бъде между %s и %s.\",\n  minlength:      \"Стойността е прекалено кратка. Мин. дължина: %s символа.\",\n  maxlength:      \"Стойността е прекалено дълга. Макс. дължина: %s символа.\",\n  length:         \"Дължината на стойността трябва да бъде между %s и %s символа.\",\n  mincheck:       \"Трябва да изберете поне %s стойности.\",\n  maxcheck:       \"Трябва да изберете най-много %s стойности.\",\n  check:          \"Трябва да изберете между %s и %s стойности.\",\n  equalto:        \"Стойността трябва да съвпада.\"\n});\n\nParsley.setLocale('bg');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/ca.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('ca', {\n  defaultMessage: \"Aquest valor sembla ser invàlid.\",\n  type: {\n    email:        \"Aquest valor ha de ser una adreça de correu electrònic vàlida.\",\n    url:          \"Aquest valor ha de ser una URL vàlida.\",\n    number:       \"Aquest valor ha de ser un nombre vàlid.\",\n    integer:      \"Aquest valor ha de ser un nombre enter vàlid.\",\n    digits:       \"Aquest valor només pot contenir dígits.\",\n    alphanum:     \"Aquest valor ha de ser alfanumèric.\"\n  },\n  notblank:       \"Aquest valor no pot ser buit.\",\n  required:       \"Aquest valor és obligatori.\",\n  pattern:        \"Aquest valor és incorrecte.\",\n  min:            \"Aquest valor no pot ser menor que %s.\",\n  max:            \"Aquest valor no pot ser major que %s.\",\n  range:          \"Aquest valor ha d'estar entre %s i %s.\",\n  minlength:      \"Aquest valor és massa curt. La longitud mínima és de %s caràcters.\",\n  maxlength:      \"Aquest valor és massa llarg. La longitud màxima és de %s caràcters.\",\n  length:         \"La longitud d'aquest valor ha de ser d'entre %s i %s caràcters.\",\n  mincheck:       \"Has de marcar un mínim de %s opcions.\",\n  maxcheck:       \"Has de marcar un màxim de %s opcions.\",\n  check:          \"Has de marcar entre %s i %s opcions.\",\n  equalto:        \"Aquest valor ha de ser el mateix.\"\n});\n\nParsley.setLocale('ca');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/cs.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('cs', {\n  dateiso:  \"Tato položka musí být datum ve formátu RRRR-MM-DD.\",\n  minwords: \"Tato položka musí mít délku nejméně %s slov.\",\n  maxwords: \"Tato položka musí mít délku nejvíce %s slov.\",\n  words:    \"Tato položka musí být od %s do %s slov dlouhá.\",\n  gt:       \"Tato hodnota musí být větší.\",\n  gte:      \"Tato hodnota musí být větší nebo rovna.\",\n  lt:       \"Tato hodnota musí být menší.\",\n  lte:      \"Tato hodnota musí být menší nebo rovna.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/cs.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('cs', {\n  defaultMessage: \"Tato položka je neplatná.\",\n  type: {\n    email:        \"Tato položka musí být e-mailová adresa.\",\n    url:          \"Tato položka musí být platná URL adresa.\",\n    number:       \"Tato položka musí být číslo.\",\n    integer:      \"Tato položka musí být celé číslo.\",\n    digits:       \"Tato položka musí být kladné celé číslo.\",\n    alphanum:     \"Tato položka musí být alfanumerická.\"\n  },\n  notblank:       \"Tato položka nesmí být prázdná.\",\n  required:       \"Tato položka je povinná.\",\n  pattern:        \"Tato položka je neplatná.\",\n  min:            \"Tato položka musí být větší nebo rovna %s.\",\n  max:            \"Tato položka musí být menší nebo rovna %s.\",\n  range:          \"Tato položka musí být v rozsahu od %s do %s.\",\n  minlength:      \"Tato položka musí mít nejméně %s znaků.\",\n  maxlength:      \"Tato položka musí mít nejvíce %s znaků.\",\n  length:         \"Tato položka musí mít délku od %s do %s znaků.\",\n  mincheck:       \"Je nutné vybrat alespoň %s možností.\",\n  maxcheck:       \"Je nutné vybrat nejvýše %s možností.\",\n  check:          \"Je nutné vybrat od %s do %s možností.\",\n  equalto:        \"Tato položka musí být stejná.\"\n});\n\nParsley.setLocale('cs');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/da.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('da', {\n  defaultMessage: \"Indtast venligst en korrekt værdi.\",\n  type: {\n    email:        \"Indtast venligst en korrekt emailadresse.\",\n    url:          \"Indtast venligst en korrekt internetadresse.\",\n    number:       \"Indtast venligst et tal.\",\n    integer:      \"Indtast venligst et heltal.\",\n    digits:       \"Dette felt må kun bestå af tal.\",\n    alphanum:     \"Dette felt skal indeholde både tal og bogstaver.\"\n  },\n  notblank:       \"Dette felt må ikke være tomt.\",\n  required:       \"Dette felt er påkrævet.\",\n  pattern:        \"Ugyldig indtastning.\",\n  min:            \"Dette felt skal indeholde et tal som er større end eller lig med %s.\",\n  max:            \"Dette felt skal indeholde et tal som er mindre end eller lig med %s.\",\n  range:          \"Dette felt skal indeholde et tal mellem %s og %s.\",\n  minlength:      \"Indtast venligst mindst %s tegn.\",\n  maxlength:      \"Dette felt kan højst indeholde %s tegn.\",\n  length:         \"Længden af denne værdi er ikke korrekt. Værdien skal være mellem %s og %s tegn lang.\",\n  mincheck:       \"Vælg mindst %s muligheder.\",\n  maxcheck:       \"Vælg op til %s muligheder.\",\n  check:          \"Vælg mellem %s og %s muligheder.\",\n  equalto:        \"De to felter er ikke ens.\"\n});\n\nParsley.setLocale('da');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/de.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('de', {\n  dateiso:  \"Die Eingabe muss ein gültiges Datum sein (YYYY-MM-DD).\",\n  minwords: \"Die Eingabe ist zu kurz. Sie muss aus %s oder mehr Wörtern bestehen.\",\n  maxwords: \"Die Eingabe ist zu lang. Sie muss aus %s oder weniger Wörtern bestehen.\",\n  words:    \"Die Länge der Eingabe ist ungültig. Sie muss zwischen %s und %s Wörter enthalten.\",\n  gt:       \"Die Eingabe muss größer sein.\",\n  gte:      \"Die Eingabe muss größer oder gleich sein.\",\n  lt:       \"Die Eingabe muss kleiner sein.\",\n  lte:      \"Die Eingabe muss kleiner oder gleich sein.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/de.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('de', {\n  defaultMessage: \"Die Eingabe scheint nicht korrekt zu sein.\",\n  type: {\n    email:        \"Die Eingabe muss eine gültige E-Mail-Adresse sein.\",\n    url:          \"Die Eingabe muss eine gültige URL sein.\",\n    number:       \"Die Eingabe muss eine Zahl sein.\",\n    integer:      \"Die Eingabe muss eine Zahl sein.\",\n    digits:       \"Die Eingabe darf nur Ziffern enthalten.\",\n    alphanum:     \"Die Eingabe muss alphanumerisch sein.\"\n  },\n  notblank:       \"Die Eingabe darf nicht leer sein.\",\n  required:       \"Dies ist ein Pflichtfeld.\",\n  pattern:        \"Die Eingabe scheint ungültig zu sein.\",\n  min:            \"Die Eingabe muss größer oder gleich %s sein.\",\n  max:            \"Die Eingabe muss kleiner oder gleich %s sein.\",\n  range:          \"Die Eingabe muss zwischen %s und %s liegen.\",\n  minlength:      \"Die Eingabe ist zu kurz. Es müssen mindestens %s Zeichen eingegeben werden.\",\n  maxlength:      \"Die Eingabe ist zu lang. Es dürfen höchstens %s Zeichen eingegeben werden.\",\n  length:         \"Die Länge der Eingabe ist ungültig. Es müssen zwischen %s und %s Zeichen eingegeben werden.\",\n  mincheck:       \"Wählen Sie mindestens %s Angaben aus.\",\n  maxcheck:       \"Wählen Sie maximal %s Angaben aus.\",\n  check:          \"Wählen Sie zwischen %s und %s Angaben.\",\n  equalto:        \"Dieses Feld muss dem anderen entsprechen.\"\n});\n\nParsley.setLocale('de');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/el.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('el', {\n  dateiso:  \"Η τιμή πρέπει να είναι μια έγκυρη ημερομηνία (YYYY-MM-DD).\",\n  minwords: \"Το κείμενο είναι πολύ μικρό. Πρέπει να έχει %s ή και περισσότερες λέξεις.\",\n  maxwords: \"Το κείμενο είναι πολύ μεγάλο. Πρέπει να έχει %s ή και λιγότερες λέξεις.\",\n  words:    \"Το μήκος του κειμένου είναι μη έγκυρο. Πρέπει να είναι μεταξύ %s και %s λεξεων.\",\n  gt:       \"Η τιμή πρέπει να είναι μεγαλύτερη.\",\n  gte:      \"Η τιμή πρέπει να είναι μεγαλύτερη ή ίση.\",\n  lt:       \"Η τιμή πρέπει να είναι μικρότερη.\",\n  lte:      \"Η τιμή πρέπει να είναι μικρότερη ή ίση.\",\n  notequalto: \"Η τιμή πρέπει να είναι διαφορετική.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/el.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('el', {\n  defaultMessage: \"Η τιμή φαίνεται να είναι μη έγκυρη.\",\n  type: {\n    email:        \"Η τιμή πρέπει να είναι ένα έγκυρο email.\",\n    url:          \"Η τιμή πρέπει να είναι ένα έγκυρο url.\",\n    number:       \"Η τιμή πρέπει να είναι ένας έγκυρος αριθμός.\",\n    integer:      \"Η τιμή πρέπει να είναι ένας έγκυρος ακέραιος.\",\n    digits:       \"Η τιμή πρέπει να είναι ψηφία.\",\n    alphanum:     \"Η τιμή πρέπει να είναι αλφαριθμητικό.\"\n  },\n  notblank:       \"Η τιμή δεν πρέπει να είναι κενή.\",\n  required:       \"Η τιμή αυτή απαιτείται.\",\n  pattern:        \"Η τιμή φαίνεται να είναι μη έγκυρη.\",\n  min:            \"Η τιμή πρέπει να είναι μεγαλύτερη ή ίση με %s.\",\n  max:            \"Η τιμή πρέπει να είναι μικρότερη ή ίση με %s.\",\n  range:          \"Η τιμή πρέπει να είναι μεταξύ %s και %s.\",\n  minlength:      \"Το κείμενο είναι πολύ μικρό. Πρέπει να είναι %s ή και περισσότεροι χαρακτήρες.\",\n  maxlength:      \"Η κείμενο είναι πολύ μεγάλο. Πρέπει να είναι %s ή και λιγότεροι χαρακτήρες.\",\n  length:         \"Το μήκος του κειμένου είναι μη έγκυρο. Πρέπει να είναι μεταξύ %s και %s χαρακτήρων.\",\n  mincheck:       \"Πρέπει να επιλέξετε τουλάχιστον %s επιλογές.\",\n  maxcheck:       \"Πρέπει να επιλέξετε %s ή λιγότερες επιλογές.\",\n  check:          \"Πρέπει να επιλέξετε μεταξύ %s και %s επίλογων.\",\n  equalto:        \"Η τιμή πρέπει να είναι η ίδια.\"\n});\n\nParsley.setLocale('el');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/en.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('en', {\n  dateiso:  \"This value should be a valid date (YYYY-MM-DD).\",\n  minwords: \"This value is too short. It should have %s words or more.\",\n  maxwords: \"This value is too long. It should have %s words or fewer.\",\n  words:    \"This value length is invalid. It should be between %s and %s words long.\",\n  gt:       \"This value should be greater.\",\n  gte:      \"This value should be greater or equal.\",\n  lt:       \"This value should be less.\",\n  lte:      \"This value should be less or equal.\",\n  notequalto: \"This value should be different.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/en.js":"// This is included with the Parsley library itself,\n// thus there is no use in adding it to your project.\nimport Parsley from '../parsley/main';\n\nParsley.addMessages('en', {\n  defaultMessage: \"This value seems to be invalid.\",\n  type: {\n    email:        \"This value should be a valid email.\",\n    url:          \"This value should be a valid url.\",\n    number:       \"This value should be a valid number.\",\n    integer:      \"This value should be a valid integer.\",\n    digits:       \"This value should be digits.\",\n    alphanum:     \"This value should be alphanumeric.\"\n  },\n  notblank:       \"This value should not be blank.\",\n  required:       \"This value is required.\",\n  pattern:        \"This value seems to be invalid.\",\n  min:            \"This value should be greater than or equal to %s.\",\n  max:            \"This value should be lower than or equal to %s.\",\n  range:          \"This value should be between %s and %s.\",\n  minlength:      \"This value is too short. It should have %s characters or more.\",\n  maxlength:      \"This value is too long. It should have %s characters or fewer.\",\n  length:         \"This value length is invalid. It should be between %s and %s characters long.\",\n  mincheck:       \"You must select at least %s choices.\",\n  maxcheck:       \"You must select %s choices or fewer.\",\n  check:          \"You must select between %s and %s choices.\",\n  equalto:        \"This value should be the same.\"\n});\n\nParsley.setLocale('en');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/es.js":"// ParsleyConfig definition if not already set\n// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('es', {\n  defaultMessage: \"Este valor parece ser inválido.\",\n  type: {\n    email:        \"Este valor debe ser un correo válido.\",\n    url:          \"Este valor debe ser una URL válida.\",\n    number:       \"Este valor debe ser un número válido.\",\n    integer:      \"Este valor debe ser un número válido.\",\n    digits:       \"Este valor debe ser un dígito válido.\",\n    alphanum:     \"Este valor debe ser alfanumérico.\"\n  },\n  notblank:       \"Este valor no debe estar en blanco.\",\n  required:       \"Este valor es requerido.\",\n  pattern:        \"Este valor es incorrecto.\",\n  min:            \"Este valor no debe ser menor que %s.\",\n  max:            \"Este valor no debe ser mayor que %s.\",\n  range:          \"Este valor debe estar entre %s y %s.\",\n  minlength:      \"Este valor es muy corto. La longitud mínima es de %s caracteres.\",\n  maxlength:      \"Este valor es muy largo. La longitud máxima es de %s caracteres.\",\n  length:         \"La longitud de este valor debe estar entre %s y %s caracteres.\",\n  mincheck:       \"Debe seleccionar al menos %s opciones.\",\n  maxcheck:       \"Debe seleccionar %s opciones o menos.\",\n  check:          \"Debe seleccionar entre %s y %s opciones.\",\n  equalto:        \"Este valor debe ser idéntico.\"\n});\n\nParsley.setLocale('es');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/eu.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('eu', {\n  defaultMessage: \"Balio hau baliogabekoa dirudi.\",\n  type: {\n    email:        \"Balio honek posta balioduna izan behar da.\",\n    url:          \"Balio honek URL balioduna izan behar da.\",\n    number:       \"Balio honek zenbaki balioduna izan behar da.\",\n    integer:      \"Balio honek zenbaki balioduna izan behar da.\",\n    digits:       \"Balio honek digitu balioduna izan behar da.\",\n    alphanum:     \"Balio honek alfanumerikoa izan behar da.\"\n  },\n  notblank:       \"Balio honek ezin da hutsik egon.\",\n  required:       \"Balio hau nahitaezkoa da.\",\n  pattern:        \"Balio hau ez da zuzena.\",\n  min:            \"Balio honek %s baino baxuagoa ezin da izan.\",\n  max:            \"Balio honek %s baino altuagoa ezin da izan.\",\n  range:          \"Balio honek %s eta %s artean egon behar da.\",\n  minlength:      \"Balio hau oso motza da. Gutxienezko luzera %s karakteretakoa da.\",\n  maxlength:      \"Balio hau oso luzea da. Gehienezko luzera %s karakteretakoa da.\",\n  length:         \"Balio honen luzera %s eta %s karaketere artean egon behar da.\",\n  mincheck:       \"%s aukera hautatu behar dituzu gutxienez.\",\n  maxcheck:       \"%s aukera edo gutxiago hautatu behar dituzu.\",\n  check:          \"%s eta %s aukeren artean hautatu behar duzu.\",\n  equalto:        \"Balio honek berbera izan behar da.\"\n});\n\nParsley.setLocale('eu');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/fa.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('fa', {\n  defaultMessage: \"این مقدار صحیح نمی باشد\",\n  type: {\n    email:        \"این مقدار باید یک ایمیل معتبر باشد\",\n    url:          \"این مقدار باید یک آدرس معتبر باشد\",\n    number:       \"این مقدار باید یک عدد معتبر باشد\",\n    integer:      \"این مقدار باید یک عدد صحیح معتبر باشد\",\n    digits:       \"این مقدار باید یک عدد باشد\",\n    alphanum:     \"این مقدار باید حروف الفبا باشد\"\n  },\n  notblank:       \"این مقدار نباید خالی باشد\",\n  required:       \"این مقدار باید وارد شود\",\n  pattern:        \"این مقدار به نظر می رسد نامعتبر است\",\n  min:            \"این مقدیر باید بزرگتر با مساوی %s باشد\",\n  max:            \"این مقدار باید کمتر و یا مساوی %s باشد\",\n  range:          \"این مقدار باید بین %s و %s باشد\",\n  minlength:      \"این مقدار بیش از حد کوتاه است. باید %s کاراکتر یا بیشتر باشد.\",\n  maxlength:      \"این مقدار بیش از حد طولانی است. باید %s کاراکتر یا کمتر باشد.\",\n  length:         \"این مقدار نامعتبر است و باید بین %s و %s باشد\",\n  mincheck:       \"شما حداقل باید %s گزینه را انتخاب کنید.\",\n  maxcheck:       \"شما حداکثر می‌توانید %s انتخاب داشته باشید.\",\n  check:          \"باید بین %s و %s مورد انتخاب کنید\",\n  equalto:        \"این مقدار باید یکسان باشد\"\n});\n\nParsley.setLocale('fa');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/fi.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('fi', {\n  dateiso: \"Sy&ouml;t&auml; oikea p&auml;iv&auml;m&auml;&auml;r&auml; (YYYY-MM-DD).\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/fi.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('fi', {\n  defaultMessage: \"Sy&ouml;tetty arvo on virheellinen.\",\n  type: {\n    email:        \"S&auml;hk&ouml;postiosoite on virheellinen.\",\n    url:          \"Url-osoite on virheellinen.\",\n    number:       \"Sy&ouml;t&auml; numero.\",\n    integer:      \"Sy&ouml;t&auml; kokonaisluku.\",\n    digits:       \"Sy&ouml;t&auml; ainoastaan numeroita.\",\n    alphanum:     \"Sy&ouml;t&auml; ainoastaan kirjaimia tai numeroita.\"\n  },\n  notblank:       \"T&auml;m&auml; kentt&auml;&auml; ei voi j&auml;tt&auml;&auml; tyhj&auml;ksi.\",\n  required:       \"T&auml;m&auml; kentt&auml; on pakollinen.\",\n  pattern:        \"Sy&ouml;tetty arvo on virheellinen.\",\n  min:            \"Sy&ouml;t&auml; arvo joka on yht&auml; suuri tai suurempi kuin %s.\",\n  max:            \"Sy&ouml;t&auml; arvo joka on pienempi tai yht&auml; suuri kuin %s.\",\n  range:          \"Sy&ouml;t&auml; arvo v&auml;lilt&auml;: %s-%s.\",\n  minlength:      \"Sy&ouml;tetyn arvon t&auml;ytyy olla v&auml;hint&auml;&auml;n %s merkki&auml; pitk&auml;.\",\n  maxlength:      \"Sy&ouml;tetty arvo saa olla enint&auml;&auml;n %s merkki&auml; pitk&auml;.\",\n  length:         \"Sy&ouml;tetyn arvon t&auml;ytyy olla v&auml;hint&auml;&auml;n %s ja enint&auml;&auml;n %s merkki&auml; pitk&auml;.\",\n  mincheck:       \"Valitse v&auml;hint&auml;&auml;n %s vaihtoehtoa.\",\n  maxcheck:       \"Valitse enint&auml;&auml;n %s vaihtoehtoa.\",\n  check:          \"Valitse %s-%s vaihtoehtoa.\",\n  equalto:        \"Salasanat eiv&auml;t t&auml;sm&auml;&auml;.\"\n});\n\nParsley.setLocale('fi');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/fr.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('fr', {\n  dateiso:    \"Cette valeur n'est pas une date valide (YYYY-MM-DD).\",\n  minwords:   \"Cette valeur est trop courte. Elle doit contenir au moins %s mots.\",\n  maxwords:   \"Cette valeur est trop longue. Elle doit contenir tout au plus %s mots.\",\n  words:      \"Cette valeur est invalide. Elle doit contenir entre %s et %s mots.\",\n  gt:         \"Cette valeur doit être plus grande.\",\n  gte:        \"Cette valeur doit être plus grande ou égale.\",\n  lt:         \"Cette valeur doit être plus petite.\",\n  lte:        \"Cette valeur doit être plus petite ou égale.\",\n  notequalto: \"Cette valeur doit être différente.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/fr.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('fr', {\n  defaultMessage: \"Cette valeur semble non valide.\",\n  type: {\n    email:        \"Cette valeur n'est pas une adresse email valide.\",\n    url:          \"Cette valeur n'est pas une URL valide.\",\n    number:       \"Cette valeur doit être un nombre.\",\n    integer:      \"Cette valeur doit être un entier.\",\n    digits:       \"Cette valeur doit être numérique.\",\n    alphanum:     \"Cette valeur doit être alphanumérique.\"\n  },\n  notblank:       \"Cette valeur ne peut pas être vide.\",\n  required:       \"Ce champ est requis.\",\n  pattern:        \"Cette valeur semble non valide.\",\n  min:            \"Cette valeur ne doit pas être inférieure à %s.\",\n  max:            \"Cette valeur ne doit pas excéder %s.\",\n  range:          \"Cette valeur doit être comprise entre %s et %s.\",\n  minlength:      \"Cette chaîne est trop courte. Elle doit avoir au minimum %s caractères.\",\n  maxlength:      \"Cette chaîne est trop longue. Elle doit avoir au maximum %s caractères.\",\n  length:         \"Cette valeur doit contenir entre %s et %s caractères.\",\n  mincheck:       \"Vous devez sélectionner au moins %s choix.\",\n  maxcheck:       \"Vous devez sélectionner %s choix maximum.\",\n  check:          \"Vous devez sélectionner entre %s et %s choix.\",\n  equalto:        \"Cette valeur devrait être identique.\"\n});\n\nParsley.setLocale('fr');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/he.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('he', {\n  dateiso: \"ערך זה צריך להיות תאריך בפורמט (YYYY-MM-DD).\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/he.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('he', {\n  defaultMessage: \"נראה כי ערך זה אינו תקף.\",\n  type: {\n    email:        \"ערך זה צריך להיות כתובת אימייל.\",\n    url:          \"ערך זה צריך להיות URL תקף.\",\n    number:       \"ערך זה צריך להיות מספר.\",\n    integer:      \"ערך זה צריך להיות מספר שלם.\",\n    digits:       \"ערך זה צריך להיות ספרתי.\",\n    alphanum:     \"ערך זה צריך להיות אלפאנומרי.\"\n  },\n  notblank:       \"ערך זה אינו יכול להשאר ריק.\",\n  required:       \"ערך זה דרוש.\",\n  pattern:        \"נראה כי ערך זה אינו תקף.\",\n  min:            \"ערך זה צריך להיות לכל הפחות %s.\",\n  max:            \"ערך זה צריך להיות לכל היותר %s.\",\n  range:          \"ערך זה צריך להיות בין %s ל-%s.\",\n  minlength:      \"ערך זה קצר מידי. הוא צריך להיות לכל הפחות %s תווים.\",\n  maxlength:      \"ערך זה ארוך מידי. הוא צריך להיות לכל היותר %s תווים.\",\n  length:         \"ערך זה אינו באורך תקף. האורך צריך להיות בין %s ל-%s תווים.\",\n  mincheck:       \"אנא בחר לפחות %s אפשרויות.\",\n  maxcheck:       \"אנא בחר לכל היותר %s אפשרויות.\",\n  check:          \"אנא בחר בין %s ל-%s אפשרויות.\",\n  equalto:        \"ערך זה צריך להיות זהה.\"\n});\n\nParsley.setLocale('he');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/hr.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('hr', {\n  dateiso:  \"Ovo polje treba sadržavati ispravno unešen datum (GGGG-MM-DD).\",\n  minwords: \"Unos je prekratak. Treba sadržavati %s ili više riječi.\",\n  maxwords: \"Unos je predugačak. Treba sadržavati %s ili manje riječi.\",\n  words:    \"Neispravna duljina unosa. Treba sadržavati između %s i %s riječi.\",\n  gt:       \"Ova vrijednost treba biti veća.\",\n  gte:      \"Ova vrijednost treba biti veća ili jednaka.\",\n  lt:       \"Ova vrijednost treba biti manja.\",\n  lte:      \"Ova vrijednost treba biti manja ili jednaka.\",\n  notequalto: \"Ova vrijednost treba biti drugačija.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/hr.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('hr', {\n  defaultMessage: \"Neispravan unos.\",\n  type: {\n    email: \"Ovo polje treba sadržavati ispravnu email adresu.\",\n    url: \"Ovo polje treba sadržavati ispravni url.\",\n    number: \"Ovo polje treba sadržavati ispravno upisan broj.\",\n    integer: \"Ovo polje treba sadržavati ispravno upisan cijeli broj.\",\n    digits: \"Ovo polje treba sadržavati znamenke.\",\n    alphanum: \"Ovo polje treba sadržavati brojke ili slova.\"\n  },\n  notblank: \"Ovo polje ne smije biti prazno.\",\n  required: \"Ovo polje je obavezno.\",\n  pattern: \"Neispravan unos.\",\n  min: \"Vrijednost treba biti jednaka ili veća od %s.\",\n  max: \"Vrijednost treba biti jednaka ili manja od %s.\",\n  range: \"Vrijednost treba biti između %s i %s.\",\n  minlength: \"Unos je prekratak. Treba sadržavati %s ili više znakova.\",\n  maxlength: \"Unos je predugačak. Treba sadržavati %s ili manje znakova.\",\n  length: \"Neispravna duljina unosa. Treba sadržavati između %s i %s znakova.\",\n  mincheck: \"Treba odabrati najmanje %s izbora.\",\n  maxcheck: \"Treba odabrati %s ili manje izbora.\",\n  check: \"Treba odabrati između %s i %s izbora.\",\n  equalto: \"Ova vrijednost treba biti ista.\"\n});\n\nParsley.setLocale('hr');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/hu.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('hu', {\n  dateiso:  \"A mező értéke csak érvényes dátum lehet (YYYY-MM-DD).\",\n  minwords: \"Minimum %s szó megadása szükséges.\",\n  maxwords: \"Maximum %s szó megadása engedélyezett.\",\n  words:    \"Minimum %s, maximum %s szó megadása szükséges.\",\n  gt:       \"A mező értéke nagyobb kell legyen.\",\n  gte:      \"A mező értéke nagyobb vagy egyenlő kell legyen.\",\n  lt:       \"A mező értéke kevesebb kell legyen.\",\n  lte:      \"A mező értéke kevesebb vagy egyenlő kell legyen.\",\n  notequalto: \"Az érték különböző kell legyen.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/hu.js":"// This is included with the Parsley library itself,\n// thus there is no use in adding it to your project.\nimport Parsley from '../parsley/main';\n\nParsley.addMessages('hu', {\n  defaultMessage: \"Érvénytelen mező.\",\n  type: {\n    email:        \"Érvénytelen email cím.\",\n    url:          \"Érvénytelen URL cím.\",\n    number:       \"Érvénytelen szám.\",\n    integer:      \"Érvénytelen egész szám.\",\n    digits:       \"Érvénytelen szám.\",\n    alphanum:     \"Érvénytelen alfanumerikus érték.\"\n  },\n  notblank:       \"Ez a mező nem maradhat üresen.\",\n  required:       \"A mező kitöltése kötelező.\",\n  pattern:        \"Érvénytelen érték.\",\n  min:            \"A mező értéke nagyobb vagy egyenlő kell legyen mint %s.\",\n  max:            \"A mező értéke kisebb vagy egyenlő kell legyen mint %s.\",\n  range:          \"A mező értéke %s és %s közé kell essen.\",\n  minlength:      \"Legalább %s karakter megadása szükséges.\",\n  maxlength:      \"Legfeljebb %s karakter megadása engedélyezett.\",\n  length:         \"Nem megfelelő karakterszám. Minimum %s, maximum %s karakter adható meg.\",\n  mincheck:       \"Legalább %s értéket kell kiválasztani.\",\n  maxcheck:       \"Maximum %s értéket lehet kiválasztani.\",\n  check:          \"Legalább %s, legfeljebb %s értéket kell kiválasztani.\",\n  equalto:        \"A mező értéke nem egyező.\"\n});\n\nParsley.setLocale('hu');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/id.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('id', {\n  dateiso: \"Harus tanggal yang valid (YYYY-MM-DD).\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/id.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('id', {\n  defaultMessage: \"tidak valid\",\n  type: {\n    email:        \"email tidak valid\",\n    url:          \"url tidak valid\",\n    number:       \"nomor tidak valid\",\n    integer:      \"integer tidak valid\",\n    digits:       \"harus berupa digit\",\n    alphanum:     \"harus berupa alphanumeric\"\n  },\n  notblank:       \"tidak boleh kosong\",\n  required:       \"tidak boleh kosong\",\n  pattern:        \"tidak valid\",\n  min:            \"harus lebih besar atau sama dengan %s.\",\n  max:            \"harus lebih kecil atau sama dengan %s.\",\n  range:          \"harus dalam rentang %s dan %s.\",\n  minlength:      \"terlalu pendek, minimal %s karakter atau lebih.\",\n  maxlength:      \"terlalu panjang, maksimal %s karakter atau kurang.\",\n  length:         \"panjang karakter harus dalam rentang %s dan %s\",\n  mincheck:       \"pilih minimal %s pilihan\",\n  maxcheck:       \"pilih maksimal %s pilihan\",\n  check:          \"pilih antar %s dan %s pilihan\",\n  equalto:        \"harus sama\"\n});\n\nParsley.setLocale('id');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/it.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('it', {\n  dateiso: \"Inserire una data valida (AAAA-MM-GG).\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/it.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('it', {\n  defaultMessage: \"Questo valore sembra essere non valido.\",\n  type: {\n    email:        \"Questo valore deve essere un indirizzo email valido.\",\n    url:          \"Questo valore deve essere un URL valido.\",\n    number:       \"Questo valore deve essere un numero valido.\",\n    integer:      \"Questo valore deve essere un numero valido.\",\n    digits:       \"Questo valore deve essere di tipo numerico.\",\n    alphanum:     \"Questo valore deve essere di tipo alfanumerico.\"\n  },\n  notblank:       \"Questo valore non deve essere vuoto.\",\n  required:       \"Questo valore è richiesto.\",\n  pattern:        \"Questo valore non è corretto.\",\n  min:            \"Questo valore deve essere maggiore di %s.\",\n  max:            \"Questo valore deve essere minore di %s.\",\n  range:          \"Questo valore deve essere compreso tra %s e %s.\",\n  minlength:      \"Questo valore è troppo corto. La lunghezza minima è di %s caratteri.\",\n  maxlength:      \"Questo valore è troppo lungo. La lunghezza massima è di %s caratteri.\",\n  length:         \"La lunghezza di questo valore deve essere compresa fra %s e %s caratteri.\",\n  mincheck:       \"Devi scegliere almeno %s opzioni.\",\n  maxcheck:       \"Devi scegliere al più %s opzioni.\",\n  check:          \"Devi scegliere tra %s e %s opzioni.\",\n  equalto:        \"Questo valore deve essere identico.\"\n});\n\nParsley.setLocale('it');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/ja.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('ja', {\n  dateiso:  \"有効な日付を入力してください。 (YYYY-MM-DD).\",\n  minwords: \"語句が短すぎます。 %s 語以上で入力してください。\",\n  maxwords: \"語句が長すぎます。 %s 語以内で入力してください。\",\n  words:    \"語句の長さが正しくありません。 %s 語から %s 語の間で入力してください。\",\n  gt:       \"より大きい値を入力してください。\",\n  gte:      \"より大きいか、同じ値を入力してください。\",\n  lt:       \"より小さい値を入力してください。\",\n  lte:      \"より小さいか、同じ値を入力してください。\",\n  notequalto: \"異なる値を入力してください。\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/ja.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('ja', {\n  defaultMessage: \"無効な値です。\",\n  type: {\n    email:        \"有効なメールアドレスを入力してください。\",\n    url:          \"有効なURLを入力してください。\",\n    number:       \"数値を入力してください。\",\n    integer:      \"整数を入力してください。\",\n    digits:       \"数字を入力してください。\",\n    alphanum:     \"英数字を入力してください。\"\n  },\n  notblank:       \"この値を入力してください\",\n  required:       \"この値は必須です。\",\n  pattern:        \"この値は無効です。\",\n  min:            \"%s 以上の値にしてください。\",\n  max:            \"%s 以下の値にしてください。\",\n  range:          \"%s から %s の値にしてください。\",\n  minlength:      \"%s 文字以上で入力してください。\",\n  maxlength:      \"%s 文字以下で入力してください。\",\n  length:         \"%s から %s 文字の間で入力してください。\",\n  mincheck:       \"%s 個以上選択してください。\",\n  maxcheck:       \"%s 個以下選択してください。\",\n  check:          \"%s から %s 個選択してください。\",\n  equalto:        \"値が違います。\"\n});\n\nParsley.setLocale('ja');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/ko.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('ko', {\n  defaultMessage: \"입력하신 내용이 올바르지 않습니다.\",\n  type: {\n    email:        \"입력하신 이메일이 유효하지 않습니다.\",\n    url:          \"입력하신 URL이 유효하지 않습니다.\",\n    number:       \"입력하신 전화번호가 올바르지 않습니다.\",\n    integer:      \"입력하신 정수가 유효하지 않습니다.\",\n    digits:       \"숫자를 입력하여 주십시오.\",\n    alphanum:     \"입력하신 내용은 알파벳과 숫자의 조합이어야 합니다.\"\n  },\n  notblank:       \"공백은 입력하실 수 없습니다.\",\n  required:       \"필수 입력사항입니다.\",\n  pattern:        \"입력하신 내용이 올바르지 않습니다.\",\n  min:            \"입력하신 내용이 %s보다 크거나 같아야 합니다. \",\n  max:            \"입력하신 내용이 %s보다 작거나 같아야 합니다.\",\n  range:          \"입력하신 내용이 %s보다 크고 %s 보다 작아야 합니다.\",\n  minlength:      \"%s 이상의 글자수를 입력하십시오. \",\n  maxlength:      \"%s 이하의 글자수를 입력하십시오. \",\n  length:         \"입력하신 내용의 글자수가 %s보다 크고 %s보다 작아야 합니다.\",\n  mincheck:       \"최소한 %s개를 선택하여 주십시오. \",\n  maxcheck:       \"%s개 또는 그보다 적게 선택하여 주십시오.\",\n  check:          \"선택하신 내용이 %s보다 크거나 %s보다 작아야 합니다.\",\n  equalto:        \"같은 값을 입력하여 주십시오.\"\n});\n\nParsley.setLocale('ko');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/lt.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('lt', {\n  dateiso:  \"Šis įrašas turi būti teisingo formato data (YYYY-MM-DD).\",\n  minwords: \"Šis įrašas turi turėti ne mažiau kaip %s žodžių.\",\n  maxwords: \"Šis įrašas turi turėti ne daugiau kaip %s žodžių.\",\n  words:    \"Šis įrašas turi turėti nuo %s iki %s žodžių.\",\n  gt:       \"Ši vertė turi būti didesnė.\",\n  gte:      \"Ši vertė turi būti didesnė arba lygi.\",\n  lt:       \"Ši vertė turi būti mažesnė.\",\n  lte:      \"Ši vertė turi būti mažesnė arba lygi.\",\n  notequalto: \"Ši vertė turi būti skirtinga.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/lt.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('lt', {\n  defaultMessage: \"Šis įrašas neteisingas.\",\n  type: {\n    email:        \"Šis įrašas nėra teisingas el. paštas.\",\n    url:          \"Šis įrašas nėra teisingas url.\",\n    number:       \"Šis įrašas nėra skaičius.\",\n    integer:      \"Šis įrašas nėra sveikasis skaičius.\",\n    digits:       \"Šis įrašas turi būti skaičius.\",\n    alphanum:     \"Šis įrašas turi būti iš skaičių ir raidžių.\"\n  },\n  notblank:       \"Šis įrašas negali būti tuščias.\",\n  required:       \"Šis įrašas yra privalomas\",\n  pattern:        \"Šis įrašas neteisingas.\",\n  min:            \"Ši vertė turi būti didesnė arba lygi %s.\",\n  max:            \"Ši vertė turi būti mažesnė arba lygi %s.\",\n  range:          \"Ši vertė turi būti tarp %s ir %s.\",\n  minlength:      \"Šis įrašas per trumpas. Jis turi turėti %s simbolius arba daugiau.\",\n  maxlength:      \"Šis įrašas per ilgas. Jis turi turėti %s simbolius arba mažiau.\",\n  length:         \"Šio įrašo ilgis neteisingas. Jis turėtų būti tarp %s ir %s simbolių.\",\n  mincheck:       \"Jūs turite pasirinkti bent %s pasirinkimus.\",\n  maxcheck:       \"Jūs turite pasirinkti ne daugiau %s pasirinkimų.\",\n  check:          \"Jūs turite pasirinkti tarp %s ir %s pasirinkimų.\",\n  equalto:        \"Ši reikšmė turėtų būti vienoda.\"\n});\n\nParsley.setLocale('lt');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/lv.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('lv', {\n  dateiso:  \"Šai vērtībai jābūt korekti noformētam datumam (YYYY-MM-DD).\",\n  minwords: \"Šī vērtība ir par īsu. Tai jābūt vismaz %s vārdus garai.\",\n  maxwords: \"Šī vērtība ir par garu. Tai jābūt %s vārdus garai vai īsākai.\",\n  words:    \"Šīs vērtības garums ir nederīgs. Tai jābūt no %s līdz %s vārdus garai.\",\n  gt:       \"Šai vērtībai jābūt lielākai.\",\n  gte:      \"Šai vērtībai jābūt lielākai vai vienādai.\",\n  lt:       \"Šai vērtībai jābūt mazākai.\",\n  lte:      \"Šai vērtībai jābūt mazākai vai vienādai.\",\n  notequalto: \"Šai vērtībai jābūt atšķirīgai.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/lv.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('lv', {\n  defaultMessage: \"Šis ieraksts veikts nekorekti.\",\n  type: {\n    email:        \"Šeit jāieraksta derīgs e-pasts.\",\n    url:          \"Šeit jāieraksta korekts url.\",\n    number:       \"Šeit jāieraksta derīgs skaitlis.\",\n    integer:      \"Šeit jāieraksta vesels skaitlis.\",\n    digits:       \"Šeit jāieraksta cipari.\",\n    alphanum:     \"Šeit derīgi tikai alfabēta burti vai cipari.\"\n  },\n  notblank:       \"Šis ieraksts nedrīkst būt tukšs.\",\n  required:       \"Šis ieraksts ir obligāti jāaizpilda.\",\n  pattern:        \"Šis ieraksts aizpildīts nekorekti.\",\n  min:            \"Šai vērtībai jābūt lielākai vai vienādai ar %s.\",\n  max:            \"Šai vērtībai jābūt mazākai vai vienādai ar %s.\",\n  range:          \"Šai vērtībai jābūt starp %s un %s.\",\n  minlength:      \"Vērtībai jābūt vismaz %s simbolu garai.\",\n  maxlength:      \"Vērtībai jābūt %s simbolus garai vai īsākai.\",\n  length:         \"Šīs vērtības garums ir neatbilstošs. Tai jābūt %s līdz %s simbolus garai.\",\n  mincheck:       \"Jāizvēlas vismaz %s varianti.\",\n  maxcheck:       \"Jāizvēlas %s varianti vai mazāk.\",\n  check:          \"Jāizvēlas no %s līdz %s variantiem.\",\n  equalto:        \"Šai vērtībai jāsakrīt.\"\n});\n\nParsley.setLocale('lv');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/ms.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('ms', {\n  dateiso:  \"Nilai hendaklah berbentuk tarikh yang sah (YYYY-MM-DD).\",\n  minwords: \"Ayat terlalu pendek. Ianya perlu sekurang-kurangnya %s patah perkataan.\",\n  maxwords: \"Ayat terlalu panjang. Ianya tidak boleh melebihi %s patah perkataan.\",\n  words:    \"Panjang ayat tidak sah. Jumlah perkataan adalah diantara %s hingga %s patah perkataan.\",\n  gt:       \"Nilai lebih besar diperlukan.\",\n  gte:      \"Nilai hendaklah lebih besar atau sama.\",\n  lt:       \"Nilai lebih kecil diperlukan.\",\n  lte:      \"Nilai hendaklah lebih kecil atau sama.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/ms.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('ms', {\n  defaultMessage: \"Nilai tidak sah.\",\n  type: {\n    email:        \"Nilai mestilah dalam format emel yang sah.\",\n    url:          \"Nilai mestilah dalam bentuk url yang sah.\",\n    number:       \"Hanya nombor dibenarkan.\",\n    integer:      \"Hanya integer dibenarkan.\",\n    digits:       \"Hanya angka dibenarkan.\",\n    alphanum:     \"Hanya alfanumerik dibenarkan.\"\n  },\n  notblank:       \"Nilai ini tidak boleh kosong.\",\n  required:       \"Nilai ini wajib diisi.\",\n  pattern:        \"Bentuk nilai ini tidak sah.\",\n  min:            \"Nilai perlu lebih besar atau sama dengan %s.\",\n  max:            \"Nilai perlu lebih kecil atau sama dengan %s.\",\n  range:          \"Nilai perlu berada antara %s hingga %s.\",\n  minlength:      \"Nilai terlalu pendek. Ianya perlu sekurang-kurangnya %s huruf.\",\n  maxlength:      \"Nilai terlalu panjang. Ianya tidak boleh melebihi %s huruf.\",\n  length:         \"Panjang nilai tidak sah. Panjangnya perlu diantara %s hingga %s huruf.\",\n  mincheck:       \"Anda mesti memilih sekurang-kurangnya %s pilihan.\",\n  maxcheck:       \"Anda tidak boleh memilih lebih daripada %s pilihan.\",\n  check:          \"Anda mesti memilih diantara %s hingga %s pilihan.\",\n  equalto:        \"Nilai dimasukkan hendaklah sama.\"\n});\n\nParsley.setLocale('ms');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/nl.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('nl', {\n  dateiso:  \"Deze waarde moet een datum in het volgende formaat zijn: (YYYY-MM-DD).\",\n  minwords: \"Deze waarde moet minstens %s woorden bevatten.\",\n  maxwords: \"Deze waarde mag maximaal %s woorden bevatten.\",\n  words:    \"Deze waarde moet tussen de %s en %s woorden bevatten.\",\n  gt:       \"Deze waarde moet groter dan %s zijn.\",\n  lt:       \"Deze waarde moet kleiner dan %s zijn.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/nl.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('nl', {\n  defaultMessage: \"Deze waarde lijkt onjuist.\",\n  type: {\n    email:        \"Dit lijkt geen geldig e-mail adres te zijn.\",\n    url:          \"Dit lijkt geen geldige URL te zijn.\",\n    number:       \"Deze waarde moet een nummer zijn.\",\n    integer:      \"Deze waarde moet een nummer zijn.\",\n    digits:       \"Deze waarde moet numeriek zijn.\",\n    alphanum:     \"Deze waarde moet alfanumeriek zijn.\"\n  },\n  notblank:       \"Deze waarde mag niet leeg zijn.\",\n  required:       \"Dit veld is verplicht.\",\n  pattern:        \"Deze waarde lijkt onjuist te zijn.\",\n  min:            \"Deze waarde mag niet lager zijn dan %s.\",\n  max:            \"Deze waarde mag niet groter zijn dan %s.\",\n  range:          \"Deze waarde moet tussen %s en %s liggen.\",\n  minlength:      \"Deze tekst is te kort. Deze moet uit minimaal %s karakters bestaan.\",\n  maxlength:      \"Deze waarde is te lang. Deze mag maximaal %s karakters lang zijn.\",\n  length:         \"Deze waarde moet tussen %s en %s karakters lang zijn.\",\n  equalto:        \"Deze waardes moeten identiek zijn.\"\n});\n\nParsley.setLocale('nl');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/no.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('no', {\n  defaultMessage: \"Verdien er ugyldig.\",\n  type: {\n    email:        \"Verdien må være en gyldig e-postadresse.\",\n    url:          \"Verdien må være en gyldig url.\",\n    number:       \"Verdien må være et gyldig tall.\",\n    integer:      \"Verdien må være et gyldig heltall.\",\n    digits:       \"Verdien må være et siffer.\",\n    alphanum:     \"Verdien må være alfanumerisk\"\n  },\n  notblank:       \"Verdien kan ikke være blank.\",\n  required:       \"Verdien er obligatorisk.\",\n  pattern:        \"Verdien er ugyldig.\",\n  min:            \"Verdien må være større eller lik %s.\",\n  max:            \"Verdien må være mindre eller lik %s.\",\n  range:          \"Verdien må være mellom %s and %s.\",\n  minlength:      \"Verdien er for kort. Den må bestå av minst %s tegn.\",\n  maxlength:      \"Verdien er for lang. Den kan bestå av maksimalt %s tegn.\",\n  length:         \"Verdien har ugyldig lengde. Den må være mellom %s og %s tegn lang.\",\n  mincheck:       \"Du må velge minst %s alternativer.\",\n  maxcheck:       \"Du må velge %s eller færre alternativer.\",\n  check:          \"Du må velge mellom %s og %s alternativer.\",\n  equalto:        \"Verdien må være lik.\"\n});\n\nParsley.setLocale('no');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/pl.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('pl', {\n  defaultMessage: \"Wartość wygląda na nieprawidłową\",\n  type: {\n    email:        \"Wpisz poprawny adres e-mail.\",\n    url:          \"Wpisz poprawny adres URL.\",\n    number:       \"Wpisz poprawną liczbę.\",\n    integer:      \"Dozwolone są jedynie liczby całkowite.\",\n    digits:       \"Dozwolone są jedynie cyfry.\",\n    alphanum:     \"Dozwolone są jedynie znaki alfanumeryczne.\"\n  },\n  notblank:       \"Pole nie może być puste.\",\n  required:       \"Pole jest wymagane.\",\n  pattern:        \"Pole zawiera nieprawidłową wartość.\",\n  min:            \"Wartość nie może być mniejsza od %s.\",\n  max:            \"Wartość nie może być większa od %s.\",\n  range:          \"Wartość powinna zaweriać się pomiędzy %s a %s.\",\n  minlength:      \"Minimalna ilość znaków wynosi %s.\",\n  maxlength:      \"Maksymalna ilość znaków wynosi %s.\",\n  length:         \"Ilość znaków wynosi od %s do %s.\",\n  mincheck:       \"Wybierz minimalnie %s opcji.\",\n  maxcheck:       \"Wybierz maksymalnie %s opcji.\",\n  check:          \"Wybierz od %s do %s opcji.\",\n  equalto:        \"Wartości nie są identyczne.\"\n});\n\nParsley.setLocale('pl');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/pt-br.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('pt-br', {\n  defaultMessage: \"Este valor parece ser inválido.\",\n  type: {\n    email:        \"Este campo deve ser um email válido.\",\n    url:          \"Este campo deve ser um URL válida.\",\n    number:       \"Este campo deve ser um número válido.\",\n    integer:      \"Este campo deve ser um inteiro válido.\",\n    digits:       \"Este campo deve conter apenas dígitos.\",\n    alphanum:     \"Este campo deve ser alfa numérico.\"\n  },\n  notblank:       \"Este campo não pode ficar vazio.\",\n  required:       \"Este campo é obrigatório.\",\n  pattern:        \"Este campo parece estar inválido.\",\n  min:            \"Este campo deve ser maior ou igual a %s.\",\n  max:            \"Este campo deve ser menor ou igual a %s.\",\n  range:          \"Este campo deve estar entre %s e %s.\",\n  minlength:      \"Este campo é pequeno demais. Ele deveria ter %s caracteres ou mais.\",\n  maxlength:      \"Este campo é grande demais. Ele deveria ter %s caracteres ou menos.\",\n  length:         \"O tamanho deste campo é inválido. Ele deveria ter entre %s e %s caracteres.\",\n  mincheck:       \"Você deve escolher pelo menos %s opções.\",\n  maxcheck:       \"Você deve escolher %s opções ou mais\",\n  check:          \"Você deve escolher entre %s e %s opções.\",\n  equalto:        \"Este valor deveria ser igual.\"\n});\n\nParsley.setLocale('pt-br');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/pt-pt.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('pt-pt', {\n  defaultMessage: \"Este valor parece ser inválido.\",\n  type: {\n    email:        \"Este campo deve ser um email válido.\",\n    url:          \"Este campo deve ser um URL válido.\",\n    number:       \"Este campo deve ser um número válido.\",\n    integer:      \"Este campo deve ser um número inteiro válido.\",\n    digits:       \"Este campo deve conter apenas dígitos.\",\n    alphanum:     \"Este campo deve ser alfanumérico.\"\n  },\n  notblank:       \"Este campo não pode ficar vazio.\",\n  required:       \"Este campo é obrigatório.\",\n  pattern:        \"Este campo parece estar inválido.\",\n  min:            \"Este valor deve ser maior ou igual a %s.\",\n  max:            \"Este valor deve ser menor ou igual a %s.\",\n  range:          \"Este valor deve estar entre %s e %s.\",\n  minlength:      \"Este campo é pequeno demais. Deve ter %s caracteres ou mais.\",\n  maxlength:      \"Este campo é grande demais. Deve ter %s caracteres ou menos.\",\n  length:         \"O tamanho deste campo é inválido. Ele deveria ter entre %s e %s caracteres.\",\n  mincheck:       \"Escolha pelo menos %s opções.\",\n  maxcheck:       \"Escolha %s opções ou mais\",\n  check:          \"Escolha entre %s e %s opções.\",\n  equalto:        \"Este valor deveria ser igual.\"\n});\n\nParsley.setLocale('pt-pt');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/ro.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('ro', {\n  dateiso:    \"Trebuie să fie o dată corectă (YYYY-MM-DD).\",\n  minwords:   \"Textul e prea scurt. Trebuie să aibă cel puțin %s cuvinte.\",\n  maxwords:   \"Textul e prea lung. Trebuie să aibă cel mult %s cuvinte.\",\n  words:      \"Textul trebuie să aibă cel puțin %s și cel mult %s caractere.\",\n  gt:         \"Valoarea ar trebui să fie mai mare.\",\n  gte:        \"Valoarea ar trebui să fie mai mare sau egală.\",\n  lt:         \"Valoarea ar trebui să fie mai mică.\",\n  lte:        \"Valoarea ar trebui să fie mai mică sau egală.\",\n  notequalto: \"Valoarea ar trebui să fie diferită.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/ro.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('ro', {\n  defaultMessage: \"Acest câmp nu este completat corect.\",\n  type: {\n    email:        \"Trebuie să scrii un email valid.\",\n    url:          \"Trebuie să scrii un link valid\",\n    number:       \"Trebuie să scrii un număr valid\",\n    integer:      \"Trebuie să scrii un număr întreg valid\",\n    digits:       \"Trebuie să conțină doar cifre.\",\n    alphanum:     \"Trebuie să conțină doar cifre sau litere.\"\n  },\n  notblank:       \"Acest câmp nu poate fi lăsat gol.\",\n  required:       \"Acest câmp trebuie să fie completat.\",\n  pattern:        \"Acest câmp nu este completat corect.\",\n  min:            \"Trebuie să fie ceva mai mare sau egal cu %s.\",\n  max:            \"Trebuie să fie ceva mai mic sau egal cu %s.\",\n  range:          \"Valoarea trebuie să fie între %s și %s.\",\n  minlength:      \"Trebuie să scrii cel puțin %s caractere.\",\n  maxlength:      \"Trebuie să scrii cel mult %s caractere.\",\n  length:         \"Trebuie să scrii cel puțin %s și %s cel mult %s caractere.\",\n  mincheck:       \"Trebuie să alegi cel puțin %s opțiuni.\",\n  maxcheck:       \"Poți alege maxim %s opțiuni.\",\n  check:          \"Trebuie să alegi între %s sau %s.\",\n  equalto:        \"Trebuie să fie la fel.\"\n});\n\nParsley.setLocale('ro');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/ru.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('ru', {\n  dateiso:  \"Это значение должно быть корректной датой (ГГГГ-ММ-ДД).\",\n  minwords: \"Это значение должно содержать не менее %s слов.\",\n  maxwords: \"Это значение должно содержать не более %s слов.\",\n  words:    \"Это значение должно содержать от %s до %s слов.\",\n  gt:       \"Это значение должно быть больше.\",\n  gte:      \"Это значение должно быть больше или равно.\",\n  lt:       \"Это значение должно быть меньше.\",\n  lte:      \"Это значение должно быть меньше или равно.\",\n  notequalto: \"Это значение должно отличаться.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/ru.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('ru', {\n  defaultMessage: \"Некорректное значение.\",\n  type: {\n    email:        \"Введите адрес электронной почты.\",\n    url:          \"Введите URL адрес.\",\n    number:       \"Введите число.\",\n    integer:      \"Введите целое число.\",\n    digits:       \"Введите только цифры.\",\n    alphanum:     \"Введите буквенно-цифровое значение.\"\n  },\n  notblank:       \"Это поле должно быть заполнено.\",\n  required:       \"Обязательное поле.\",\n  pattern:        \"Это значение некорректно.\",\n  min:            \"Это значение должно быть не менее чем %s.\",\n  max:            \"Это значение должно быть не более чем %s.\",\n  range:          \"Это значение должно быть от %s до %s.\",\n  minlength:      \"Это значение должно содержать не менее %s символов.\",\n  maxlength:      \"Это значение должно содержать не более %s символов.\",\n  length:         \"Это значение должно содержать от %s до %s символов.\",\n  mincheck:       \"Выберите не менее %s значений.\",\n  maxcheck:       \"Выберите не более %s значений.\",\n  check:          \"Выберите от %s до %s значений.\",\n  equalto:        \"Это значение должно совпадать.\"\n});\n\nParsley.setLocale('ru');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/sk.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('sk', {\n  dateiso:  \"Prosím zadajte dátum vo formáte RRRR-MM-DD.\",\n  minwords: \"Prosím zadajte hodnotu dlhú %s slov a viacej.\",\n  maxwords: \"Prosím zadajte hodnotu kratšiu ako %s slov.\",\n  words:    \"Prosím zadajte hodnotu medzi %s a %s slov.\",\n  gt:       \"Táto hodnota musí byť väčšia.\",\n  gte:      \"Táto hodnota musí byť väčšia alebo rovná.\",\n  lt:       \"Táto hodnota musí byť menšia.\",\n  lte:      \"Táto hodnota musí byť menšia alebo rovná.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/sk.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('sk', {\n  defaultMessage: \"Prosím zadajte správnu hodnotu.\",\n  type: {\n    email:        \"Prosím zadajte správnu emailovú adresu.\",\n    url:          \"Prosím zadajte platnú URL adresu.\",\n    number:       \"Toto pole môže obsahovať len čísla\",\n    integer:      \"Toto pole môže obsahovať len celé čísla\",\n    digits:       \"Toto pole môže obsahovať len kladné celé čísla.\",\n    alphanum:     \"Toto pole môže obsahovať len alfanumerické znaky.\"\n  },\n  notblank:       \"Toto pole nesmie byť prázdne.\",\n  required:       \"Toto pole je povinné.\",\n  pattern:        \"Toto pole je je neplatné.\",\n  min:            \"Prosím zadajte hodnotu väčšiu alebo rovnú %s.\",\n  max:            \"Prosím zadajte hodnotu menšiu alebo rovnú %s.\",\n  range:          \"Prosím zadajte hodnotu v rozmedzí %s a %s\",\n  minlength:      \"Prosím zadajte hodnotu dlhú %s znakov a viacej.\",\n  maxlength:      \"Prosím zadajte hodnotu kratšiu ako %s znakov.\",\n  length:         \"Prosím zadajte hodnotu medzi %s a %s znakov.\",\n  mincheck:       \"Je nutné vybrať minimálne %s z možností.\",\n  maxcheck:       \"Je nutné vybrať maximálne %s z možností.\",\n  check:          \"Je nutné vybrať od %s do %s z možností.\",\n  equalto:        \"Prosím zadajte rovnakú hodnotu.\"\n});\n\nParsley.setLocale('sk');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/sl.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('sl', {\n  dateiso:  \"Vnesite datum v ISO obliki (YYYY-MM-DD).\",\n  minwords: \"Vpis je prekratek. Vpisati morate najmnaj %s besed.\",\n  maxwords: \"Vpis je predolg. Vpišete lahko največ %s besed.\",\n  words:    \"Dolžina vpisa je napačna. Dolžina je lahko samo med %s in %s besed.\",\n  gt:       \"Vpisani podatek mora biti večji.\",\n  gte:      \"Vpisani podatek mora biti enak ali večji.\",\n  lt:       \"Vpisani podatek mora biti manjši.\",\n  lte:      \"Vpisani podatek mora biti enak ali manjši.\",\n  notequalto: \"Vpisana vrednost mora biti drugačna.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/sl.js":"// This is included with the Parsley library itself,\n// thus there is no use in adding it to your project.\nimport Parsley from '../parsley/main';\n\nParsley.addMessages('sl', {\n  defaultMessage: \"Podatek ne ustreza vpisnim kriterijem.\",\n  type: {\n    email:        \"Vpišite pravilen email.\",\n    url:          \"Vpišite pravilen url naslov.\",\n    number:       \"Vpišite številko.\",\n    integer:      \"Vpišite celo število brez decimalnih mest.\",\n    digits:       \"Vpišite samo cifre.\",\n    alphanum:     \"Vpišite samo alfanumerične znake (cifre in črke).\"\n  },\n  notblank:       \"To polje ne sme biti prazno.\",\n  required:       \"To polje je obvezno.\",\n  pattern:        \"Podatek ne ustreza vpisnim kriterijem.\",\n  min:            \"Vrednost mora biti višja ali enaka kot %s.\",\n  max:            \"Vrednost mora biti nižja ali enaka kot  %s.\",\n  range:          \"Vrednost mora biti med %s in %s.\",\n  minlength:      \"Vpis je prekratek. Mora imeti najmanj %s znakov.\",\n  maxlength:      \"Vpis je predolg. Lahko ima največ %s znakov.\",\n  length:         \"Število vpisanih znakov je napačno. Število znakov je lahko samo med %s in %s.\",\n  mincheck:       \"Izbrati morate vsaj %s možnosti.\",\n  maxcheck:       \"Izberete lahko največ %s možnosti.\",\n  check:          \"Število izbranih možnosti je lahko samo med %s in %s.\",\n  equalto:        \"Vnos mora biti enak.\"\n});\n\nParsley.setLocale('sl');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/sq.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('sq', {\n  defaultMessage: \"Kjo vlere eshte e pasakte.\",\n  type: {\n    email:        \"Duhet te jete nje email i vlefshem.\",\n    url:          \"Duhet te jete nje URL e vlefshme.\",\n    number:       \"Duhet te jete numer.\",\n    integer:      \"Kjo vlere duhet te jete integer.\",\n    digits:       \"Kjo vlere duhet te permbaje digit.\",\n    alphanum:     \"Kjo vlere duhet te permbaje vetel alphanumeric.\"\n  },\n  notblank:       \"Nuk mund te lihet bosh.\",\n  required:       \"Eshte e detyrueshme.\",\n  pattern:        \"Kjo vlere eshte e pasakte.\",\n  min:            \"Duhet te jete me e madhe ose baraz me %s.\",\n  max:            \"Duhet te jete me e vogel ose baraz me %s.\",\n  range:          \"Duhet te jete midis %s dhe %s.\",\n  minlength:      \"Kjo vlere eshte shume e shkurter. Ajo duhet te permbaje min %s karaktere.\",\n  maxlength:      \"Kjo vlere eshte shume e gjate. Ajo duhet te permbaje max %s karaktere.\",\n  length:         \"Gjatesia e kesaj vlere eshte e pasakte. Ajo duhet te jete midis %s dhe %s karakteresh.\",\n  mincheck:       \"Ju duhet te zgjidhni te pakten %s vlere.\",\n  maxcheck:       \"Ju duhet te zgjidhni max %s vlera.\",\n  check:          \"Ju mund te zgjidhni midis %s dhe %s vlerash.\",\n  equalto:        \"Kjo vlere duhet te jete e njejte.\"\n});\n\nParsley.setLocale('sq');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/sr.extra.js":"// Extra validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('sr', {\n  dateiso:  \"Unesite validan datum u formatu YYYY-MM-DD.\",\n  minwords: \"Potrebno je da unesete %s ili više reči.\",\n  maxwords: \"Moguće je uneti maksimalno %s reči.\",\n  words:    \"Potrebno je da unesete između %s i %s reči.\",\n  gt:       \"Ova vrednost mora da bude veća.\",\n  gte:      \"Ova vrednost mora da bude veća ili jednaka.\",\n  lt:       \"Ova vrednost mora da bude manja.\",\n  lte:      \"Ova vrednost mora da bude manja ili jednaka.\",\n  notequalto: \"Sadržaj ovog polja mora biti različit.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/sr.js":"// Validation errors messages for Parsley\n// Load this after Parsley\n\nParsley.addMessages('sr', {\n  defaultMessage: \"Uneta vrednost nije validna.\",\n  type: {\n    email:        \"Unesite pravilnu email adresu.\",\n    url:          \"Unesite pravilnu url adresu.\",\n    number:       \"Unesite numeričku vrednost.\",\n    integer:      \"Unesite ceo broj bez decimala.\",\n    digits:       \"Unesite samo brojeve.\",\n    alphanum:     \"Unesite samo alfanumeričke znake (slova i brojeve).\"\n  },\n  notblank:       \"Ovo polje ne sme biti prazno.\",\n  required:       \"Ovo polje je obavezno.\",\n  pattern:        \"Uneta vrednost nije validna.\",\n  min:            \"Vrednost mora biti veća ili jednaka %s.\",\n  max:            \"Vrednost mora biti manja ili jednaka %s.\",\n  range:          \"Vrednost mora biti između %s i %s.\",\n  minlength:      \"Unos je prekratak. Mora imati najmanje %s znakova.\",\n  maxlength:      \"Unos je predug. Može imati najviše %s znakova.\",\n  length:         \"Dužina unosa je pogrešna. Broj znakova mora biti između %s i %s.\",\n  mincheck:       \"Morate izabrati minimalno %s opcija.\",\n  maxcheck:       \"Možete izabrati najviše %s opcija.\",\n  check:          \"Broj izabranih opcija mora biti između %s i %s.\",\n  equalto:        \"Unos mora biti jednak.\"\n});\n\nParsley.setLocale('sr');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/sv.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('sv', {\n  dateiso: \"Ange ett giltigt datum (ÅÅÅÅ-MM-DD).\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/sv.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('sv', {\n  defaultMessage: \"Ogiltigt värde.\",\n  type: {\n    email:        \"Ange en giltig e-postadress.\",\n    url:          \"Ange en giltig URL.\",\n    number:       \"Ange ett giltigt nummer.\",\n    integer:      \"Ange ett heltal.\",\n    digits:       \"Ange endast siffror.\",\n    alphanum:     \"Ange endast bokstäver och siffror.\"\n  },\n  notblank:       \"Värdet får inte vara tomt.\",\n  required:       \"Måste fyllas i.\",\n  pattern:        \"Värdet är ej giltigt.\",\n  min:            \"Värdet måste vara större än eller lika med %s.\",\n  max:            \"Värdet måste vara mindre än eller lika med %s.\",\n  range:          \"Värdet måste vara mellan %s och %s.\",\n  minlength:      \"Värdet måste vara minst %s tecken.\",\n  maxlength:      \"Värdet får maximalt innehålla %s tecken.\",\n  length:         \"Värdet måste vara mellan %s och %s tecken.\",\n  mincheck:       \"Minst %s val måste göras.\",\n  maxcheck:       \"Maximalt %s val får göras.\",\n  check:          \"Mellan %s och %s val måste göras.\",\n  equalto:        \"Värdena måste vara lika.\"\n});\n\nParsley.setLocale('sv');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/th.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('th', {\n  defaultMessage: \"ค่านี้ดูเหมือนว่าจะไม่ถูกต้อง\",\n  type: {\n    email:        \"ค่านี้ควรจะเป็นอีเมลที่ถูกต้อง\",\n    url:          \"ค่านี้ควรจะเป็น url ที่ถูกต้อง\",\n    number:       \"ค่านี้ควรจะเป็นตัวเลขที่ถูกต้อง\",\n    integer:      \"ค่านี้ควรจะเป็นจำนวนเต็มที่ถูกต้อง\",\n    digits:       \"ค่านี้ควรเป็นทศนิยมที่ถูกต้อง\",\n    alphanum:     \"ค่านี้ควรเป็นอักขระตัวอักษรหรือตัวเลขที่ถูกต้อง\"\n  },\n  notblank:       \"ค่านี้ไม่ควรจะว่าง\",\n  required:       \"ค่านี้จำเป็น\",\n  pattern:        \"ค่านี้ดูเหมือนว่าจะไม่ถูกต้อง\",\n  min:            \"ค่านี้ควรมากกว่าหรือเท่ากับ %s.\",\n  max:            \"ค่านี้ควรจะน้อยกว่าหรือเท่ากับ %s.\",\n  range:          \"ค่ายี้ควรจะอยู่ระหว่าง %s และ %s.\",\n  minlength:      \"ค่านี้สั้นเกินไป ควรจะมี %s อักขระหรือมากกว่า\",\n  maxlength:      \"ค่านี้ยาวเกินไป ควรจะมี %s อักขระหรือน้อยกว่า\",\n  length:         \"ความยาวของค่านี้ไม่ถูกต้อง ควรมีความยาวอยู่ระหว่าง %s และ %s อักขระ\",\n  mincheck:       \"คุณควรเลือกอย่างน้อย %s ตัวเลือก\",\n  maxcheck:       \"คุณควรเลือก %s ตัวเลือกหรือน้อยกว่า\",\n  check:          \"คุณควรเลือกระหว่าง %s และ %s ตัวเลือก\",\n  equalto:        \"ค่านี้ควรจะเหมือนกัน\"\n});\n\nParsley.setLocale('th');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/tr.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('tr', {\n  defaultMessage: \"Girdiğiniz değer geçerli değil.\",\n  type: {\n    email:        \"Geçerli bir e-mail adresi yazmanız gerekiyor.\",\n    url:          \"Geçerli bir bağlantı adresi yazmanız gerekiyor.\",\n    number:       \"Geçerli bir sayı yazmanız gerekiyor.\",\n    integer:      \"Geçerli bir tamsayı yazmanız gerekiyor.\",\n    digits:       \"Geçerli bir rakam yazmanız gerekiyor.\",\n    alphanum:     \"Geçerli bir alfanümerik değer yazmanız gerekiyor.\"\n  },\n  notblank:       \"Bu alan boş bırakılamaz.\",\n  required:       \"Bu alan boş bırakılamaz.\",\n  pattern:        \"Girdiğiniz değer geçerli değil.\",\n  min:            \"Bu alan %s değerinden büyük ya da bu değere eşit olmalı.\",\n  max:            \"Bu alan %s değerinden küçük ya da bu değere eşit olmalı.\",\n  range:          \"Bu alan %s ve %s değerleri arasında olmalı.\",\n  minlength:      \"Bu alanın uzunluğu %s karakter veya daha fazla olmalı.\",\n  maxlength:      \"Bu alanın uzunluğu %s karakter veya daha az olmalı.\",\n  length:         \"Bu alanın uzunluğu %s ve %s karakter arasında olmalı.\",\n  mincheck:       \"En az %s adet seçim yapmalısınız.\",\n  maxcheck:       \"En fazla %s seçim yapabilirsiniz.\",\n  check:          \"Bu alan için en az %s, en fazla %s seçim yapmalısınız.\",\n  equalto:        \"Bu alanın değeri aynı olmalı.\"\n});\n\nParsley.setLocale('tr');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/ua.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('ua', {\n  dateiso:  \"Це значення повинно бути коректною датою (РРРР-ММ-ДД).\",\n  minwords: \"Це значення повинно містити не менше %s слів.\",\n  maxwords: \"Це значення повинно містити не більше %s слів.\",\n  words:    \"Це значення повинно містити від %s до %s слів.\",\n  gt:       \"Це значення повинно бути більше.\",\n  gte:      \"Це значення повинно бути більше або дорівнює.\",\n  lt:       \"Це значення повинно бути менше.\",\n  lte:      \"Це значення повинно бути менше або дорівнює.\",\n  notequalto: \"Це значення повинно відрізнятися.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/ua.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('ua', {\n  defaultMessage: \"Некоректне значення.\",\n  type: {\n    email:        \"Введіть адресу електронної пошти.\",\n    url:          \"Введіть URL адресу.\",\n    number:       \"Введіть число.\",\n    integer:      \"Введіть ціле число.\",\n    digits:       \"Введіть тільки цифри.\",\n    alphanum:     \"Введіть буквено-цифрове значення.\"\n  },\n  notblank:       \"Це поле має бути заповненим.\",\n  required:       \"Обов'язкове поле.\",\n  pattern:        \"Це значення некоректне.\",\n  min:            \"Це значення повинно бути не менше ніж %s.\",\n  max:            \"Це значення повинно бути не більше ніж %s.\",\n  range:          \"Це значення повинно бути від %s до %s.\",\n  minlength:      \"Це значення повинно містити не менше %s символів.\",\n  maxlength:      \"Це значення повинно містити не більше %s символів.\",\n  length:         \"Це значення повинно містити від %s до %s символів.\",\n  mincheck:       \"Виберіть не менше %s значень.\",\n  maxcheck:       \"Виберіть не більше %s значень.\",\n  check:          \"Виберіть від %s до %s значень.\",\n  equalto:        \"Це значення повинно співпадати.\"\n});\n\nParsley.setLocale('ua');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/uk.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('uk', {\n  dateiso:  \"Це значення має бути коректною датою (РРРР-ММ-ДД).\",\n  minwords: \"Це значення повинно містити не менше %s слів.\",\n  maxwords: \"Це значення повинно містити не більше %s слів.\",\n  words:    \"Це значення повинно містити від %s до %s слів.\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/uk.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('uk', {\n  defaultMessage: \"Некоректне значення.\",\n  type: {\n    email:        \"Введіть адресу електронної пошти.\",\n    url:          \"Введіть URL-адресу.\",\n    number:       \"Введіть число.\",\n    integer:      \"Введіть ціле число.\",\n    digits:       \"Введіть тільки цифри.\",\n    alphanum:     \"Введіть буквено-цифрове значення.\"\n  },\n  notblank:       \"Це поле повинно бути заповнено.\",\n  required:       \"Обов'язкове поле\",\n  pattern:        \"Це значення некоректно.\",\n  min:            \"Це значення повинно бути не менше ніж %s.\",\n  max:            \"Це значення повинно бути не більше ніж %s.\",\n  range:          \"Це значення повинно бути від %s до %s.\",\n  minlength:      \"Це значення повинно містити не менше ніж %s символів.\",\n  maxlength:      \"Це значення повинно містити не більше ніж %s символів.\",\n  length:         \"Це значення повинно містити від %s до %s символів.\",\n  mincheck:       \"Виберіть не менше %s значень.\",\n  maxcheck:       \"Виберіть не більше %s значень.\",\n  check:          \"Виберіть від %s до %s значень.\",\n  equalto:        \"Це значення повинно збігатися.\"\n});\n\nParsley.setLocale('uk');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/zh_cn.extra.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('zh-cn', {\n  dateiso: \"请输入正确格式的日期 (YYYY-MM-DD).\"\n});\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/zh_cn.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('zh-cn', {\n  defaultMessage: \"不正确的值\",\n  type: {\n    email:        \"请输入一个有效的电子邮箱地址\",\n    url:          \"请输入一个有效的链接\",\n    number:       \"请输入正确的数字\",\n    integer:      \"请输入正确的整数\",\n    digits:       \"请输入正确的号码\",\n    alphanum:     \"请输入字母或数字\"\n  },\n  notblank:       \"请输入值\",\n  required:       \"必填项\",\n  pattern:        \"格式不正确\",\n  min:            \"输入值请大于或等于 %s\",\n  max:            \"输入值请小于或等于 %s\",\n  range:          \"输入值应该在 %s 到 %s 之间\",\n  minlength:      \"请输入至少 %s 个字符\",\n  maxlength:      \"请输入至多 %s 个字符\",\n  length:         \"字符长度应该在 %s 到 %s 之间\",\n  mincheck:       \"请至少选择 %s 个选项\",\n  maxcheck:       \"请选择不超过 %s 个选项\",\n  check:          \"请选择 %s 到 %s 个选项\",\n  equalto:        \"输入值不同\"\n});\n\nParsley.setLocale('zh-cn');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/i18n/zh_tw.js":"// Validation errors messages for Parsley\nimport Parsley from '../parsley';\n\nParsley.addMessages('zh-tw', {\n  defaultMessage: \"這個值似乎是無效的。\",\n  type: {\n    email:        \"請輸入一個正確的電子郵件地址。\",\n    url:          \"請輸入一個有效的網址。\",\n    number:       \"請輸入一個數字。\",\n    integer:      \"請輸入一個整數。\",\n    digits:       \"這個欄位只接受數字。\",\n    alphanum:     \"這個欄位只接受英文字母或是數字。\"\n  },\n  notblank:       \"這個欄位不能為空白。\",\n  required:       \"這個欄位必須填寫。\",\n  pattern:        \"這個值似乎是無效的。\",\n  min:            \"輸入的值應該大於或等於 %s\",\n  max:            \"輸入的值應該小於或等於 %s\",\n  range:          \"輸入的值應該在 %s 和 %s 之間。\",\n  minlength:      \"輸入的值至少要有 %s 個字元。\",\n  maxlength:      \"輸入的值最多可以有 %s 個字元。\",\n  length:         \"字元長度應該在 %s 和 %s 之間。\",\n  mincheck:       \"你至少要選擇 %s 個項目。\",\n  maxcheck:       \"你最多可選擇 %s 個項目。\",\n  check:          \"你必須選擇 %s 到 %s 個項目。\",\n  equalto:        \"輸入值不同。\"\n});\n\nParsley.setLocale('zh-tw');\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/parsley/base.js":"import $ from 'jquery';\nimport Utils from './utils';\n\nvar Base = function () {\n  this.__id__ = Utils.generateID();\n};\n\nBase.prototype = {\n  asyncSupport: true, // Deprecated\n\n  _pipeAccordingToValidationResult: function () {\n    var pipe = () => {\n      var r = $.Deferred();\n      if (true !== this.validationResult)\n        r.reject();\n      return r.resolve().promise();\n    };\n    return [pipe, pipe];\n  },\n\n  actualizeOptions: function () {\n    Utils.attr(this.$element, this.options.namespace, this.domOptions);\n    if (this.parent && this.parent.actualizeOptions)\n      this.parent.actualizeOptions();\n    return this;\n  },\n\n  _resetOptions: function (initOptions) {\n    this.domOptions = Utils.objectCreate(this.parent.options);\n    this.options = Utils.objectCreate(this.domOptions);\n    // Shallow copy of ownProperties of initOptions:\n    for (var i in initOptions) {\n      if (initOptions.hasOwnProperty(i))\n        this.options[i] = initOptions[i];\n    }\n    this.actualizeOptions();\n  },\n\n  _listeners: null,\n\n  // Register a callback for the given event name\n  // Callback is called with context as the first argument and the `this`\n  // The context is the current parsley instance, or window.Parsley if global\n  // A return value of `false` will interrupt the calls\n  on: function (name, fn) {\n    this._listeners = this._listeners || {};\n    var queue = this._listeners[name] = this._listeners[name] || [];\n    queue.push(fn);\n\n    return this;\n  },\n\n  // Deprecated. Use `on` instead\n  subscribe: function(name, fn) {\n    $.listenTo(this, name.toLowerCase(), fn);\n  },\n\n  // Unregister a callback (or all if none is given) for the given event name\n  off: function (name, fn) {\n    var queue = this._listeners && this._listeners[name];\n    if (queue) {\n      if (!fn) {\n        delete this._listeners[name];\n      } else {\n        for (var i = queue.length; i--; )\n          if (queue[i] === fn)\n            queue.splice(i, 1);\n      }\n    }\n    return this;\n  },\n\n  // Deprecated. Use `off`\n  unsubscribe: function(name, fn) {\n    $.unsubscribeTo(this, name.toLowerCase());\n  },\n\n  // Trigger an event of the given name\n  // A return value of `false` interrupts the callback chain\n  // Returns false if execution was interrupted\n  trigger: function (name, target, extraArg) {\n    target = target || this;\n    var queue = this._listeners && this._listeners[name];\n    var result;\n    var parentResult;\n    if (queue) {\n      for (var i = queue.length; i--; ) {\n        result = queue[i].call(target, target, extraArg);\n        if (result === false) return result;\n      }\n    }\n    if (this.parent) {\n      return this.parent.trigger(name, target, extraArg);\n    }\n    return true;\n  },\n\n  asyncIsValid: function (group, force) {\n    Utils.warnOnce(\"asyncIsValid is deprecated; please use whenValid instead\");\n    return this.whenValid({group, force});\n  },\n\n  _findRelated: function () {\n    return this.options.multiple ?\n      this.parent.$element.find(`[${this.options.namespace}multiple=\"${this.options.multiple}\"]`)\n    : this.$element;\n  }\n};\n\nexport default Base;\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/parsley/constraint.js":"import $ from 'jquery';\nimport Utils from './utils';\nimport Validator from './validator';\n\nvar Constraint = function (parsleyField, name, requirements, priority, isDomConstraint) {\n  var validatorSpec = window.Parsley._validatorRegistry.validators[name];\n  var validator = new Validator(validatorSpec);\n\n  $.extend(this, {\n    validator: validator,\n    name: name,\n    requirements: requirements,\n    priority: priority || parsleyField.options[name + 'Priority'] || validator.priority,\n    isDomConstraint: true === isDomConstraint\n  });\n  this._parseRequirements(parsleyField.options);\n};\n\nvar capitalize = function(str) {\n  var cap = str[0].toUpperCase();\n  return cap + str.slice(1);\n};\n\nConstraint.prototype = {\n  validate: function(value, instance) {\n    return this.validator.validate(value, ...this.requirementList, instance);\n  },\n\n  _parseRequirements: function(options) {\n    this.requirementList = this.validator.parseRequirements(this.requirements,\n      key => options[this.name + capitalize(key)]\n    );\n  }\n};\n\nexport default Constraint;\n\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/parsley/defaults.js":"// All these options could be overriden and specified directly in DOM using\n// `data-parsley-` default DOM-API\n// eg: `inputs` can be set in DOM using `data-parsley-inputs=\"input, textarea\"`\n// eg: `data-parsley-stop-on-first-failing-constraint=\"false\"`\n\nvar Defaults = {\n  // ### General\n\n  // Default data-namespace for DOM API\n  namespace: 'data-parsley-',\n\n  // Supported inputs by default\n  inputs: 'input, textarea, select',\n\n  // Excluded inputs by default\n  excluded: 'input[type=button], input[type=submit], input[type=reset], input[type=hidden]',\n\n  // Stop validating field on highest priority failing constraint\n  priorityEnabled: true,\n\n  // ### Field only\n\n  // identifier used to group together inputs (e.g. radio buttons...)\n  multiple: null,\n\n  // identifier (or array of identifiers) used to validate only a select group of inputs\n  group: null,\n\n  // ### UI\n  // Enable\\Disable error messages\n  uiEnabled: true,\n\n  // Key events threshold before validation\n  validationThreshold: 3,\n\n  // Focused field on form validation error. 'first'|'last'|'none'\n  focus: 'first',\n\n  // event(s) that will trigger validation before first failure. eg: `input`...\n  trigger: false,\n\n  // event(s) that will trigger validation after first failure.\n  triggerAfterFailure: 'input',\n\n  // Class that would be added on every failing validation Parsley field\n  errorClass: 'parsley-error',\n\n  // Same for success validation\n  successClass: 'parsley-success',\n\n  // Return the `$element` that will receive these above success or error classes\n  // Could also be (and given directly from DOM) a valid selector like `'#div'`\n  classHandler: function (Field) {},\n\n  // Return the `$element` where errors will be appended\n  // Could also be (and given directly from DOM) a valid selector like `'#div'`\n  errorsContainer: function (Field) {},\n\n  // ul elem that would receive errors' list\n  errorsWrapper: '<ul class=\"parsley-errors-list\"></ul>',\n\n  // li elem that would receive error message\n  errorTemplate: '<li></li>'\n};\n\nexport default Defaults;\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/parsley/factory.js":"import $ from 'jquery';\nimport Utils from './utils';\nimport Base from './base';\nimport Form from './form';\nimport Field from './field';\nimport Multiple from './multiple';\n\nvar Factory = function (element, options, parsleyFormInstance) {\n  this.$element = $(element);\n\n  // If the element has already been bound, returns its saved Parsley instance\n  var savedparsleyFormInstance = this.$element.data('Parsley');\n  if (savedparsleyFormInstance) {\n\n    // If the saved instance has been bound without a Form parent and there is one given in this call, add it\n    if ('undefined' !== typeof parsleyFormInstance && savedparsleyFormInstance.parent === window.Parsley) {\n      savedparsleyFormInstance.parent = parsleyFormInstance;\n      savedparsleyFormInstance._resetOptions(savedparsleyFormInstance.options);\n    }\n\n    if ('object' === typeof options) {\n      $.extend(savedparsleyFormInstance.options, options);\n    }\n\n    return savedparsleyFormInstance;\n  }\n\n  // Parsley must be instantiated with a DOM element or jQuery $element\n  if (!this.$element.length)\n    throw new Error('You must bind Parsley on an existing element.');\n\n  if ('undefined' !== typeof parsleyFormInstance && 'Form' !== parsleyFormInstance.__class__)\n    throw new Error('Parent instance must be a Form instance');\n\n  this.parent = parsleyFormInstance || window.Parsley;\n  return this.init(options);\n};\n\nFactory.prototype = {\n  init: function (options) {\n    this.__class__ = 'Parsley';\n    this.__version__ = '@@version';\n    this.__id__ = Utils.generateID();\n\n    // Pre-compute options\n    this._resetOptions(options);\n\n    // A Form instance is obviously a `<form>` element but also every node that is not an input and has the `data-parsley-validate` attribute\n    if (this.$element.is('form') || (Utils.checkAttr(this.$element, this.options.namespace, 'validate') && !this.$element.is(this.options.inputs)))\n      return this.bind('parsleyForm');\n\n    // Every other element is bound as a `Field` or `FieldMultiple`\n    return this.isMultiple() ? this.handleMultiple() : this.bind('parsleyField');\n  },\n\n  isMultiple: function () {\n    return (this.$element.is('input[type=radio], input[type=checkbox]')) || (this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple'));\n  },\n\n  // Multiples fields are a real nightmare :(\n  // Maybe some refactoring would be appreciated here...\n  handleMultiple: function () {\n    var name;\n    var multiple;\n    var parsleyMultipleInstance;\n\n    // Handle multiple name\n    if (this.options.multiple)\n      ; // We already have our 'multiple' identifier\n    else if ('undefined' !== typeof this.$element.attr('name') && this.$element.attr('name').length)\n      this.options.multiple = name = this.$element.attr('name');\n    else if ('undefined' !== typeof this.$element.attr('id') && this.$element.attr('id').length)\n      this.options.multiple = this.$element.attr('id');\n\n    // Special select multiple input\n    if (this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple')) {\n      this.options.multiple = this.options.multiple || this.__id__;\n      return this.bind('parsleyFieldMultiple');\n\n    // Else for radio / checkboxes, we need a `name` or `data-parsley-multiple` to properly bind it\n    } else if (!this.options.multiple) {\n      Utils.warn('To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.', this.$element);\n      return this;\n    }\n\n    // Remove special chars\n    this.options.multiple = this.options.multiple.replace(/(:|\\.|\\[|\\]|\\{|\\}|\\$)/g, '');\n\n    // Add proper `data-parsley-multiple` to siblings if we have a valid multiple name\n    if ('undefined' !== typeof name) {\n      $('input[name=\"' + name + '\"]').each((i, input) => {\n        if ($(input).is('input[type=radio], input[type=checkbox]'))\n          $(input).attr(this.options.namespace + 'multiple', this.options.multiple);\n      });\n    }\n\n    // Check here if we don't already have a related multiple instance saved\n    var $previouslyRelated = this._findRelated();\n    for (var i = 0; i < $previouslyRelated.length; i++) {\n      parsleyMultipleInstance = $($previouslyRelated.get(i)).data('Parsley');\n      if ('undefined' !== typeof parsleyMultipleInstance) {\n\n        if (!this.$element.data('FieldMultiple')) {\n          parsleyMultipleInstance.addElement(this.$element);\n        }\n\n        break;\n      }\n    }\n\n    // Create a secret Field instance for every multiple field. It will be stored in `data('FieldMultiple')`\n    // And will be useful later to access classic `Field` stuff while being in a `FieldMultiple` instance\n    this.bind('parsleyField', true);\n\n    return parsleyMultipleInstance || this.bind('parsleyFieldMultiple');\n  },\n\n  // Return proper `Form`, `Field` or `FieldMultiple`\n  bind: function (type, doNotStore) {\n    var parsleyInstance;\n\n    switch (type) {\n      case 'parsleyForm':\n        parsleyInstance = $.extend(\n          new Form(this.$element, this.domOptions, this.options),\n          new Base(),\n          window.ParsleyExtend\n        )._bindFields();\n        break;\n      case 'parsleyField':\n        parsleyInstance = $.extend(\n          new Field(this.$element, this.domOptions, this.options, this.parent),\n          new Base(),\n          window.ParsleyExtend\n        );\n        break;\n      case 'parsleyFieldMultiple':\n        parsleyInstance = $.extend(\n          new Field(this.$element, this.domOptions, this.options, this.parent),\n          new Multiple(),\n          new Base(),\n          window.ParsleyExtend\n        )._init();\n        break;\n      default:\n        throw new Error(type + 'is not a supported Parsley type');\n    }\n\n    if (this.options.multiple)\n      Utils.setAttr(this.$element, this.options.namespace, 'multiple', this.options.multiple);\n\n    if ('undefined' !== typeof doNotStore) {\n      this.$element.data('FieldMultiple', parsleyInstance);\n\n      return parsleyInstance;\n    }\n\n    // Store the freshly bound instance in a DOM element for later access using jQuery `data()`\n    this.$element.data('Parsley', parsleyInstance);\n\n    // Tell the world we have a new Form or Field instance!\n    parsleyInstance._actualizeTriggers();\n    parsleyInstance._trigger('init');\n\n    return parsleyInstance;\n  }\n};\n\nexport default Factory;\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/parsley/field.js":"import $ from 'jquery';\nimport Constraint from './constraint';\nimport UI from './ui';\nimport Utils from './utils';\n\nvar Field = function (field, domOptions, options, parsleyFormInstance) {\n  this.__class__ = 'Field';\n\n  this.$element = $(field);\n\n  // Set parent if we have one\n  if ('undefined' !== typeof parsleyFormInstance) {\n    this.parent = parsleyFormInstance;\n  }\n\n  this.options = options;\n  this.domOptions = domOptions;\n\n  // Initialize some properties\n  this.constraints = [];\n  this.constraintsByName = {};\n  this.validationResult = true;\n\n  // Bind constraints\n  this._bindConstraints();\n};\n\nvar statusMapping = {pending: null, resolved: true, rejected: false};\n\nField.prototype = {\n  // # Public API\n  // Validate field and trigger some events for mainly `UI`\n  // @returns `true`, an array of the validators that failed, or\n  // `null` if validation is not finished. Prefer using whenValidate\n  validate: function (options) {\n    if (arguments.length >= 1 && !$.isPlainObject(options)) {\n      Utils.warnOnce('Calling validate on a parsley field without passing arguments as an object is deprecated.');\n      options = {options};\n    }\n    var promise = this.whenValidate(options);\n    if (!promise)  // If excluded with `group` option\n      return true;\n    switch (promise.state()) {\n      case 'pending': return null;\n      case 'resolved': return true;\n      case 'rejected': return this.validationResult;\n    }\n  },\n\n  // Validate field and trigger some events for mainly `UI`\n  // @returns a promise that succeeds only when all validations do\n  // or `undefined` if field is not in the given `group`.\n  whenValidate: function ({force, group} =  {}) {\n    // do not validate a field if not the same as given validation group\n    this.refreshConstraints();\n    if (group && !this._isInGroup(group))\n      return;\n\n    this.value = this.getValue();\n\n    // Field Validate event. `this.value` could be altered for custom needs\n    this._trigger('validate');\n\n    return this.whenValid({force, value: this.value, _refreshed: true})\n      .always(() => { this._reflowUI(); })\n      .done(() =>   { this._trigger('success'); })\n      .fail(() =>   { this._trigger('error'); })\n      .always(() => { this._trigger('validated'); })\n      .pipe(...this._pipeAccordingToValidationResult());\n  },\n\n  hasConstraints: function () {\n    return 0 !== this.constraints.length;\n  },\n\n  // An empty optional field does not need validation\n  needsValidation: function (value) {\n    if ('undefined' === typeof value)\n      value = this.getValue();\n\n    // If a field is empty and not required, it is valid\n    // Except if `data-parsley-validate-if-empty` explicitely added, useful for some custom validators\n    if (!value.length && !this._isRequired() && 'undefined' === typeof this.options.validateIfEmpty)\n      return false;\n\n    return true;\n  },\n\n  _isInGroup: function (group) {\n    if ($.isArray(this.options.group))\n      return -1 !== $.inArray(group, this.options.group);\n    return this.options.group === group;\n  },\n\n  // Just validate field. Do not trigger any event.\n  // Returns `true` iff all constraints pass, `false` if there are failures,\n  // or `null` if the result can not be determined yet (depends on a promise)\n  // See also `whenValid`.\n  isValid: function (options) {\n    if (arguments.length >= 1 && !$.isPlainObject(options)) {\n      Utils.warnOnce('Calling isValid on a parsley field without passing arguments as an object is deprecated.');\n      var [force, value] = arguments;\n      options = {force, value};\n    }\n    var promise = this.whenValid(options);\n    if (!promise) // Excluded via `group`\n      return true;\n    return statusMapping[promise.state()];\n  },\n\n  // Just validate field. Do not trigger any event.\n  // @returns a promise that succeeds only when all validations do\n  // or `undefined` if the field is not in the given `group`.\n  // The argument `force` will force validation of empty fields.\n  // If a `value` is given, it will be validated instead of the value of the input.\n  whenValid: function ({force = false, value, group, _refreshed} = {}) {\n    // Recompute options and rebind constraints to have latest changes\n    if (!_refreshed)\n      this.refreshConstraints();\n    // do not validate a field if not the same as given validation group\n    if (group && !this._isInGroup(group))\n      return;\n\n    this.validationResult = true;\n\n    // A field without constraint is valid\n    if (!this.hasConstraints())\n      return $.when();\n\n    // Value could be passed as argument, needed to add more power to 'field:validate'\n    if ('undefined' === typeof value || null === value)\n      value = this.getValue();\n\n    if (!this.needsValidation(value) && true !== force)\n      return $.when();\n\n    var groupedConstraints = this._getGroupedConstraints();\n    var promises = [];\n    $.each(groupedConstraints, (_, constraints) => {\n      // Process one group of constraints at a time, we validate the constraints\n      // and combine the promises together.\n      var promise = Utils.all(\n        $.map(constraints, constraint => this._validateConstraint(value, constraint))\n      );\n      promises.push(promise);\n      if (promise.state() === 'rejected')\n        return false; // Interrupt processing if a group has already failed\n    });\n    return Utils.all(promises);\n  },\n\n  // @returns a promise\n  _validateConstraint: function(value, constraint) {\n    var result = constraint.validate(value, this);\n    // Map false to a failed promise\n    if (false === result)\n      result = $.Deferred().reject();\n    // Make sure we return a promise and that we record failures\n    return Utils.all([result]).fail(errorMessage => {\n      if (!(this.validationResult instanceof Array))\n        this.validationResult = [];\n      this.validationResult.push({\n        assert: constraint,\n        errorMessage: 'string' === typeof errorMessage && errorMessage\n      });\n    });\n  },\n\n  // @returns Parsley field computed value that could be overrided or configured in DOM\n  getValue: function () {\n    var value;\n\n    // Value could be overriden in DOM or with explicit options\n    if ('function' === typeof this.options.value)\n      value = this.options.value(this);\n    else if ('undefined' !== typeof this.options.value)\n      value = this.options.value;\n    else\n      value = this.$element.val();\n\n    // Handle wrong DOM or configurations\n    if ('undefined' === typeof value || null === value)\n      return '';\n\n    return this._handleWhitespace(value);\n  },\n\n  // Reset UI\n  reset: function () {\n    this._resetUI();\n    return this._trigger('reset');\n  },\n\n  // Destroy Parsley instance (+ UI)\n  destroy: function () {\n    // Field case: emit destroy event to clean UI and then destroy stored instance\n    this._destroyUI();\n    this.$element.removeData('Parsley');\n    this.$element.removeData('FieldMultiple');\n    this._trigger('destroy');\n  },\n\n  // Actualize options that could have change since previous validation\n  // Re-bind accordingly constraints (could be some new, removed or updated)\n  refreshConstraints: function () {\n    return this.actualizeOptions()._bindConstraints();\n  },\n\n  /**\n  * Add a new constraint to a field\n  *\n  * @param {String}   name\n  * @param {Mixed}    requirements      optional\n  * @param {Number}   priority          optional\n  * @param {Boolean}  isDomConstraint   optional\n  */\n  addConstraint: function (name, requirements, priority, isDomConstraint) {\n\n    if (window.Parsley._validatorRegistry.validators[name]) {\n      var constraint = new Constraint(this, name, requirements, priority, isDomConstraint);\n\n      // if constraint already exist, delete it and push new version\n      if ('undefined' !== this.constraintsByName[constraint.name])\n        this.removeConstraint(constraint.name);\n\n      this.constraints.push(constraint);\n      this.constraintsByName[constraint.name] = constraint;\n    }\n\n    return this;\n  },\n\n  // Remove a constraint\n  removeConstraint: function (name) {\n    for (var i = 0; i < this.constraints.length; i++)\n      if (name === this.constraints[i].name) {\n        this.constraints.splice(i, 1);\n        break;\n      }\n    delete this.constraintsByName[name];\n    return this;\n  },\n\n  // Update a constraint (Remove + re-add)\n  updateConstraint: function (name, parameters, priority) {\n    return this.removeConstraint(name)\n      .addConstraint(name, parameters, priority);\n  },\n\n  // # Internals\n\n  // Internal only.\n  // Bind constraints from config + options + DOM\n  _bindConstraints: function () {\n    var constraints = [];\n    var constraintsByName = {};\n\n    // clean all existing DOM constraints to only keep javascript user constraints\n    for (var i = 0; i < this.constraints.length; i++)\n      if (false === this.constraints[i].isDomConstraint) {\n        constraints.push(this.constraints[i]);\n        constraintsByName[this.constraints[i].name] = this.constraints[i];\n      }\n\n    this.constraints = constraints;\n    this.constraintsByName = constraintsByName;\n\n    // then re-add Parsley DOM-API constraints\n    for (var name in this.options)\n      this.addConstraint(name, this.options[name], undefined, true);\n\n    // finally, bind special HTML5 constraints\n    return this._bindHtml5Constraints();\n  },\n\n  // Internal only.\n  // Bind specific HTML5 constraints to be HTML5 compliant\n  _bindHtml5Constraints: function () {\n    // html5 required\n    if (this.$element.attr('required'))\n      this.addConstraint('required', true, undefined, true);\n\n    // html5 pattern\n    if ('string' === typeof this.$element.attr('pattern'))\n      this.addConstraint('pattern', this.$element.attr('pattern'), undefined, true);\n\n    // range\n    if ('undefined' !== typeof this.$element.attr('min') && 'undefined' !== typeof this.$element.attr('max'))\n      this.addConstraint('range', [this.$element.attr('min'), this.$element.attr('max')], undefined, true);\n\n    // HTML5 min\n    else if ('undefined' !== typeof this.$element.attr('min'))\n      this.addConstraint('min', this.$element.attr('min'), undefined, true);\n\n    // HTML5 max\n    else if ('undefined' !== typeof this.$element.attr('max'))\n      this.addConstraint('max', this.$element.attr('max'), undefined, true);\n\n\n    // length\n    if ('undefined' !== typeof this.$element.attr('minlength') && 'undefined' !== typeof this.$element.attr('maxlength'))\n      this.addConstraint('length', [this.$element.attr('minlength'), this.$element.attr('maxlength')], undefined, true);\n\n    // HTML5 minlength\n    else if ('undefined' !== typeof this.$element.attr('minlength'))\n      this.addConstraint('minlength', this.$element.attr('minlength'), undefined, true);\n\n    // HTML5 maxlength\n    else if ('undefined' !== typeof this.$element.attr('maxlength'))\n      this.addConstraint('maxlength', this.$element.attr('maxlength'), undefined, true);\n\n\n    // html5 types\n    var type = this.$element.attr('type');\n\n    if ('undefined' === typeof type)\n      return this;\n\n    // Small special case here for HTML5 number: integer validator if step attribute is undefined or an integer value, number otherwise\n    if ('number' === type) {\n      return this.addConstraint('type', ['number', {\n        step: this.$element.attr('step') || '1',\n        base: this.$element.attr('min') || this.$element.attr('value')\n      }], undefined, true);\n    // Regular other HTML5 supported types\n    } else if (/^(email|url|range|date)$/i.test(type)) {\n      return this.addConstraint('type', type, undefined, true);\n    }\n    return this;\n  },\n\n  // Internal only.\n  // Field is required if have required constraint without `false` value\n  _isRequired: function () {\n    if ('undefined' === typeof this.constraintsByName.required)\n      return false;\n\n    return false !== this.constraintsByName.required.requirements;\n  },\n\n  // Internal only.\n  // Shortcut to trigger an event\n  _trigger: function (eventName) {\n    return this.trigger('field:' + eventName);\n  },\n\n  // Internal only\n  // Handles whitespace in a value\n  // Use `data-parsley-whitespace=\"squish\"` to auto squish input value\n  // Use `data-parsley-whitespace=\"trim\"` to auto trim input value\n  _handleWhitespace: function (value) {\n    if (true === this.options.trimValue)\n      Utils.warnOnce('data-parsley-trim-value=\"true\" is deprecated, please use data-parsley-whitespace=\"trim\"');\n\n    if ('squish' === this.options.whitespace)\n      value = value.replace(/\\s{2,}/g, ' ');\n\n    if (('trim' === this.options.whitespace) || ('squish' === this.options.whitespace) || (true === this.options.trimValue))\n      value = Utils.trimString(value);\n\n    return value;\n  },\n\n  _isDateInput: function() {\n    var c = this.constraintsByName.type;\n    return c && c.requirements === 'date';\n  },\n\n  // Internal only.\n  // Returns the constraints, grouped by descending priority.\n  // The result is thus an array of arrays of constraints.\n  _getGroupedConstraints: function () {\n    if (false === this.options.priorityEnabled)\n      return [this.constraints];\n\n    var groupedConstraints = [];\n    var index = {};\n\n    // Create array unique of priorities\n    for (var i = 0; i < this.constraints.length; i++) {\n      var p = this.constraints[i].priority;\n      if (!index[p])\n        groupedConstraints.push(index[p] = []);\n      index[p].push(this.constraints[i]);\n    }\n    // Sort them by priority DESC\n    groupedConstraints.sort(function (a, b) { return b[0].priority - a[0].priority; });\n\n    return groupedConstraints;\n  }\n\n};\n\nexport default Field;\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/parsley/form.js":"import $ from 'jquery';\nimport Base from './base';\nimport Utils from './utils';\n\nvar Form = function (element, domOptions, options) {\n  this.__class__ = 'Form';\n\n  this.$element = $(element);\n  this.domOptions = domOptions;\n  this.options = options;\n  this.parent = window.Parsley;\n\n  this.fields = [];\n  this.validationResult = null;\n};\n\nvar statusMapping = {pending: null, resolved: true, rejected: false};\n\nForm.prototype = {\n  onSubmitValidate: function (event) {\n    // This is a Parsley generated submit event, do not validate, do not prevent, simply exit and keep normal behavior\n    if (true === event.parsley)\n      return;\n\n    // If we didn't come here through a submit button, use the first one in the form\n    var $submitSource = this._$submitSource || this.$element.find(Utils._SubmitSelector).first();\n    this._$submitSource = null;\n    this.$element.find('.parsley-synthetic-submit-button').prop('disabled', true);\n    if ($submitSource.is('[formnovalidate]'))\n      return;\n\n    var promise = this.whenValidate({event});\n\n    if ('resolved' === promise.state() && false !== this._trigger('submit')) {\n      // All good, let event go through. We make this distinction because browsers\n      // differ in their handling of `submit` being called from inside a submit event [#1047]\n    } else {\n      // Rejected or pending: cancel this submit\n      event.stopImmediatePropagation();\n      event.preventDefault();\n      if ('pending' === promise.state())\n        promise.done(() => { this._submit($submitSource); });\n    }\n  },\n\n  onSubmitButton: function(event) {\n    this._$submitSource = $(event.currentTarget);\n  },\n  // internal\n  // _submit submits the form, this time without going through the validations.\n  // Care must be taken to \"fake\" the actual submit button being clicked.\n  _submit: function ($submitSource) {\n    if (false === this._trigger('submit'))\n      return;\n    // Add submit button's data\n    if ($submitSource) {\n      var $synthetic = this.$element.find('.parsley-synthetic-submit-button').prop('disabled', false);\n      if (0 === $synthetic.length)\n        $synthetic = $('<input class=\"parsley-synthetic-submit-button\" type=\"hidden\">').appendTo(this.$element);\n      $synthetic.attr({\n        name: $submitSource.attr('name'),\n        value: $submitSource.attr('value')\n      });\n    }\n\n    this.$element.trigger($.extend($.Event('submit'), {parsley: true}));\n  },\n\n  // Performs validation on fields while triggering events.\n  // @returns `true` if all validations succeeds, `false`\n  // if a failure is immediately detected, or `null`\n  // if dependant on a promise.\n  // Consider using `whenValidate` instead.\n  validate: function (options) {\n    if (arguments.length >= 1 && !$.isPlainObject(options)) {\n      Utils.warnOnce('Calling validate on a parsley form without passing arguments as an object is deprecated.');\n      var [group, force, event] = arguments;\n      options = {group, force, event};\n    }\n    return statusMapping[ this.whenValidate(options).state() ];\n  },\n\n  whenValidate: function ({group, force, event} = {}) {\n    this.submitEvent = event;\n    if (event) {\n      this.submitEvent = $.extend({}, event, {preventDefault: () => {\n        Utils.warnOnce(\"Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`\");\n        this.validationResult = false;\n      }});\n    }\n    this.validationResult = true;\n\n    // fire validate event to eventually modify things before every validation\n    this._trigger('validate');\n\n    // Refresh form DOM options and form's fields that could have changed\n    this._refreshFields();\n\n    var promises = this._withoutReactualizingFormOptions(() => {\n      return $.map(this.fields, field => field.whenValidate({force, group}));\n    });\n\n    return Utils.all(promises)\n      .done(  () => { this._trigger('success'); })\n      .fail(  () => {\n        this.validationResult = false;\n        this.focus();\n        this._trigger('error');\n      })\n      .always(() => { this._trigger('validated'); })\n      .pipe(...this._pipeAccordingToValidationResult());\n  },\n\n  // Iterate over refreshed fields, and stop on first failure.\n  // Returns `true` if all fields are valid, `false` if a failure is detected\n  // or `null` if the result depends on an unresolved promise.\n  // Prefer using `whenValid` instead.\n  isValid: function (options) {\n    if (arguments.length >= 1 && !$.isPlainObject(options)) {\n      Utils.warnOnce('Calling isValid on a parsley form without passing arguments as an object is deprecated.');\n      var [group, force] = arguments;\n      options = {group, force};\n    }\n    return statusMapping[ this.whenValid(options).state() ];\n  },\n\n  // Iterate over refreshed fields and validate them.\n  // Returns a promise.\n  // A validation that immediately fails will interrupt the validations.\n  whenValid: function ({group, force} = {}) {\n    this._refreshFields();\n\n    var promises = this._withoutReactualizingFormOptions(() => {\n      return $.map(this.fields, field => field.whenValid({group, force}));\n    });\n    return Utils.all(promises);\n  },\n\n  // Reset UI\n  reset: function () {\n    // Form case: emit a reset event for each field\n    for (var i = 0; i < this.fields.length; i++)\n      this.fields[i].reset();\n\n    this._trigger('reset');\n  },\n\n  // Destroy Parsley instance (+ UI)\n  destroy: function () {\n    // Field case: emit destroy event to clean UI and then destroy stored instance\n    this._destroyUI();\n\n    // Form case: destroy all its fields and then destroy stored instance\n    for (var i = 0; i < this.fields.length; i++)\n      this.fields[i].destroy();\n\n    this.$element.removeData('Parsley');\n    this._trigger('destroy');\n  },\n\n  _refreshFields: function () {\n    return this.actualizeOptions()._bindFields();\n  },\n\n  _bindFields: function () {\n    var oldFields = this.fields;\n\n    this.fields = [];\n    this.fieldsMappedById = {};\n\n    this._withoutReactualizingFormOptions(() => {\n      this.$element\n      .find(this.options.inputs)\n      .not(this.options.excluded)\n      .each((_, element) => {\n        var fieldInstance = new window.Parsley.Factory(element, {}, this);\n\n        // Only add valid and not excluded `Field` and `FieldMultiple` children\n        if (('Field' === fieldInstance.__class__ || 'FieldMultiple' === fieldInstance.__class__) && (true !== fieldInstance.options.excluded)) {\n          let uniqueId = fieldInstance.__class__ + '-' + fieldInstance.__id__;\n          if ('undefined' === typeof this.fieldsMappedById[uniqueId]) {\n            this.fieldsMappedById[uniqueId] = fieldInstance;\n            this.fields.push(fieldInstance);\n          }\n        }\n      });\n\n      $.each(Utils.difference(oldFields, this.fields), (_, field) => {\n        field.reset();\n      });\n    });\n    return this;\n  },\n\n  // Internal only.\n  // Looping on a form's fields to do validation or similar\n  // will trigger reactualizing options on all of them, which\n  // in turn will reactualize the form's options.\n  // To avoid calling actualizeOptions so many times on the form\n  // for nothing, _withoutReactualizingFormOptions temporarily disables\n  // the method actualizeOptions on this form while `fn` is called.\n  _withoutReactualizingFormOptions: function (fn) {\n    var oldActualizeOptions = this.actualizeOptions;\n    this.actualizeOptions = function () { return this; };\n    var result = fn();\n    this.actualizeOptions = oldActualizeOptions;\n    return result;\n  },\n\n  // Internal only.\n  // Shortcut to trigger an event\n  // Returns true iff event is not interrupted and default not prevented.\n  _trigger: function (eventName) {\n    return this.trigger('form:' + eventName);\n  }\n\n};\n\nexport default Form;\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/parsley/main.js":"import $ from 'jquery';\nimport Utils from './utils';\nimport Defaults from './defaults';\nimport Base from './base';\nimport ValidatorRegistry from './validator_registry';\nimport UI from './ui';\nimport Form from './form';\nimport Field from './field';\nimport Multiple from './multiple';\nimport Factory from './factory';\n\nvar vernums = $.fn.jquery.split('.');\nif (parseInt(vernums[0]) <= 1 && parseInt(vernums[1]) < 8) {\n  throw \"The loaded version of jQuery is too old. Please upgrade to 1.8.x or better.\";\n}\nif (!vernums.forEach) {\n  Utils.warn('Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim');\n}\n// Inherit `on`, `off` & `trigger` to Parsley:\nvar Parsley = $.extend(new Base(), {\n    $element: $(document),\n    actualizeOptions: null,\n    _resetOptions: null,\n    Factory: Factory,\n    version: '@@version'\n  });\n\n// Supplement Field and Form with Base\n// This way, the constructors will have access to those methods\n$.extend(Field.prototype, UI.Field, Base.prototype);\n$.extend(Form.prototype, UI.Form, Base.prototype);\n// Inherit actualizeOptions and _resetOptions:\n$.extend(Factory.prototype, Base.prototype);\n\n// ### jQuery API\n// `$('.elem').parsley(options)` or `$('.elem').psly(options)`\n$.fn.parsley = $.fn.psly = function (options) {\n  if (this.length > 1) {\n    var instances = [];\n\n    this.each(function () {\n      instances.push($(this).parsley(options));\n    });\n\n    return instances;\n  }\n\n  // Return undefined if applied to non existing DOM element\n  if (!$(this).length) {\n    Utils.warn('You must bind Parsley on an existing element.');\n\n    return;\n  }\n\n  return new Factory(this, options);\n};\n\n// ### Field and Form extension\n// Ensure the extension is now defined if it wasn't previously\nif ('undefined' === typeof window.ParsleyExtend)\n  window.ParsleyExtend = {};\n\n// ### Parsley config\n// Inherit from ParsleyDefault, and copy over any existing values\nParsley.options = $.extend(Utils.objectCreate(Defaults), window.ParsleyConfig);\nwindow.ParsleyConfig = Parsley.options; // Old way of accessing global options\n\n// ### Globals\nwindow.Parsley = window.psly = Parsley;\nParsley.Utils = Utils;\nwindow.ParsleyUtils = {};\n$.each(Utils, (key, value) => {\n  if ('function' === typeof value) {\n    window.ParsleyUtils[key] = (...args) => {\n      Utils.warnOnce('Accessing `window.ParsleyUtils` is deprecated. Use `window.Parsley.Utils` instead.');\n      return Utils[key](...args);\n    };\n  }\n});\n\n// ### Define methods that forward to the registry, and deprecate all access except through window.Parsley\nvar registry = window.Parsley._validatorRegistry = new ValidatorRegistry(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);\nwindow.ParsleyValidator = {};\n$.each('setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator'.split(' '), function (i, method) {\n  window.Parsley[method] = $.proxy(registry, method);\n  window.ParsleyValidator[method] = function () {\n    Utils.warnOnce(`Accessing the method '${method}' through Validator is deprecated. Simply call 'window.Parsley.${method}(...)'`);\n    return window.Parsley[method](...arguments);\n  };\n});\n\n// ### UI\n// Deprecated global object\nwindow.Parsley.UI = UI;\nwindow.ParsleyUI = {\n  removeError: function (instance, name, doNotUpdateClass) {\n    var updateClass = true !== doNotUpdateClass;\n    Utils.warnOnce(`Accessing UI is deprecated. Call 'removeError' on the instance directly. Please comment in issue 1073 as to your need to call this method.`);\n    return instance.removeError(name, {updateClass});\n  },\n  getErrorsMessages: function (instance) {\n    Utils.warnOnce(`Accessing UI is deprecated. Call 'getErrorsMessages' on the instance directly.`);\n    return instance.getErrorsMessages();\n  }\n};\n$.each('addError updateError'.split(' '), function (i, method) {\n  window.ParsleyUI[method] = function (instance, name, message, assert, doNotUpdateClass) {\n    var updateClass = true !== doNotUpdateClass;\n    Utils.warnOnce(`Accessing UI is deprecated. Call '${method}' on the instance directly. Please comment in issue 1073 as to your need to call this method.`);\n    return instance[method](name, {message, assert, updateClass});\n  };\n});\n\n// ### PARSLEY auto-binding\n// Prevent it by setting `ParsleyConfig.autoBind` to `false`\nif (false !== window.ParsleyConfig.autoBind) {\n  $(function () {\n    // Works only on `data-parsley-validate`.\n    if ($('[data-parsley-validate]').length)\n      $('[data-parsley-validate]').parsley();\n  });\n}\n\nexport default Parsley;\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/parsley/multiple.js":"import $ from 'jquery';\n\nvar Multiple = function () {\n  this.__class__ = 'FieldMultiple';\n};\n\nMultiple.prototype = {\n  // Add new `$element` sibling for multiple field\n  addElement: function ($element) {\n    this.$elements.push($element);\n\n    return this;\n  },\n\n  // See `Field.refreshConstraints()`\n  refreshConstraints: function () {\n    var fieldConstraints;\n\n    this.constraints = [];\n\n    // Select multiple special treatment\n    if (this.$element.is('select')) {\n      this.actualizeOptions()._bindConstraints();\n\n      return this;\n    }\n\n    // Gather all constraints for each input in the multiple group\n    for (var i = 0; i < this.$elements.length; i++) {\n\n      // Check if element have not been dynamically removed since last binding\n      if (!$('html').has(this.$elements[i]).length) {\n        this.$elements.splice(i, 1);\n        continue;\n      }\n\n      fieldConstraints = this.$elements[i].data('FieldMultiple').refreshConstraints().constraints;\n\n      for (var j = 0; j < fieldConstraints.length; j++)\n        this.addConstraint(fieldConstraints[j].name, fieldConstraints[j].requirements, fieldConstraints[j].priority, fieldConstraints[j].isDomConstraint);\n    }\n\n    return this;\n  },\n\n  // See `Field.getValue()`\n  getValue: function () {\n    // Value could be overriden in DOM\n    if ('function' === typeof this.options.value)\n      return this.options.value(this);\n    else if ('undefined' !== typeof this.options.value)\n      return this.options.value;\n\n    // Radio input case\n    if (this.$element.is('input[type=radio]'))\n      return this._findRelated().filter(':checked').val() || '';\n\n    // checkbox input case\n    if (this.$element.is('input[type=checkbox]')) {\n      var values = [];\n\n      this._findRelated().filter(':checked').each(function () {\n        values.push($(this).val());\n      });\n\n      return values;\n    }\n\n    // Select multiple case\n    if (this.$element.is('select') && null === this.$element.val())\n      return [];\n\n    // Default case that should never happen\n    return this.$element.val();\n  },\n\n  _init: function () {\n    this.$elements = [this.$element];\n\n    return this;\n  }\n};\n\nexport default Multiple;\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/parsley/pubsub.js":"import $ from 'jquery';\nimport Field from './field';\nimport Form from './form';\nimport Utils from './utils';\n\nvar o = $({});\nvar deprecated = function () {\n  Utils.warnOnce(\"Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley\");\n};\n\n// Returns an event handler that calls `fn` with the arguments it expects\nfunction adapt(fn, context) {\n  // Store to allow unbinding\n  if (!fn.parsleyAdaptedCallback) {\n    fn.parsleyAdaptedCallback = function () {\n      var args = Array.prototype.slice.call(arguments, 0);\n      args.unshift(this);\n      fn.apply(context || o, args);\n    };\n  }\n  return fn.parsleyAdaptedCallback;\n}\n\nvar eventPrefix = 'parsley:';\n// Converts 'parsley:form:validate' into 'form:validate'\nfunction eventName(name) {\n  if (name.lastIndexOf(eventPrefix, 0) === 0)\n    return name.substr(eventPrefix.length);\n  return name;\n}\n\n// $.listen is deprecated. Use Parsley.on instead.\n$.listen = function (name, callback) {\n  var context;\n  deprecated();\n  if ('object' === typeof arguments[1] && 'function' === typeof arguments[2]) {\n    context = arguments[1];\n    callback = arguments[2];\n  }\n\n  if ('function' !== typeof callback)\n    throw new Error('Wrong parameters');\n\n  window.Parsley.on(eventName(name), adapt(callback, context));\n};\n\n$.listenTo = function (instance, name, fn) {\n  deprecated();\n  if (!(instance instanceof Field) && !(instance instanceof Form))\n    throw new Error('Must give Parsley instance');\n\n  if ('string' !== typeof name || 'function' !== typeof fn)\n    throw new Error('Wrong parameters');\n\n  instance.on(eventName(name), adapt(fn));\n};\n\n$.unsubscribe = function (name, fn) {\n  deprecated();\n  if ('string' !== typeof name || 'function' !== typeof fn)\n    throw new Error('Wrong arguments');\n  window.Parsley.off(eventName(name), fn.parsleyAdaptedCallback);\n};\n\n$.unsubscribeTo = function (instance, name) {\n  deprecated();\n  if (!(instance instanceof Field) && !(instance instanceof Form))\n    throw new Error('Must give Parsley instance');\n  instance.off(eventName(name));\n};\n\n$.unsubscribeAll = function (name) {\n  deprecated();\n  window.Parsley.off(eventName(name));\n  $('form,input,textarea,select').each(function () {\n    var instance = $(this).data('Parsley');\n    if (instance) {\n      instance.off(eventName(name));\n    }\n  });\n};\n\n// $.emit is deprecated. Use jQuery events instead.\n$.emit = function (name, instance) {\n  deprecated();\n  var instanceGiven = (instance instanceof Field) || (instance instanceof Form);\n  var args = Array.prototype.slice.call(arguments, instanceGiven ? 2 : 1);\n  args.unshift(eventName(name));\n  if (!instanceGiven) {\n    instance = window.Parsley;\n  }\n  instance.trigger(...args);\n};\n\nexport default {};\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/parsley/remote.js":"import $ from 'jquery';\n\nimport Parsley from './main';\n\n$.extend(true, Parsley, {\n  asyncValidators: {\n    'default': {\n      fn: function (xhr) {\n        // By default, only status 2xx are deemed successful.\n        // Note: we use status instead of state() because responses with status 200\n        // but invalid messages (e.g. an empty body for content type set to JSON) will\n        // result in state() === 'rejected'.\n        return xhr.status >= 200 && xhr.status < 300;\n      },\n      url: false\n    },\n    reverse: {\n      fn: function (xhr) {\n        // If reverse option is set, a failing ajax request is considered successful\n        return xhr.status < 200 || xhr.status >= 300;\n      },\n      url: false\n    }\n  },\n\n  addAsyncValidator: function (name, fn, url, options) {\n    Parsley.asyncValidators[name] = {\n      fn: fn,\n      url: url || false,\n      options: options || {}\n    };\n\n    return this;\n  }\n\n});\n\nParsley.addValidator('remote', {\n  requirementType: {\n    '': 'string',\n    'validator': 'string',\n    'reverse': 'boolean',\n    'options': 'object'\n  },\n\n  validateString: function (value, url, options, instance) {\n    var data = {};\n    var ajaxOptions;\n    var csr;\n    var validator = options.validator || (true === options.reverse ? 'reverse' : 'default');\n\n    if ('undefined' === typeof Parsley.asyncValidators[validator])\n      throw new Error('Calling an undefined async validator: `' + validator + '`');\n\n    url = Parsley.asyncValidators[validator].url || url;\n\n    // Fill current value\n    if (url.indexOf('{value}') > -1) {\n      url = url.replace('{value}', encodeURIComponent(value));\n    } else {\n      data[instance.$element.attr('name') || instance.$element.attr('id')] = value;\n    }\n\n    // Merge options passed in from the function with the ones in the attribute\n    var remoteOptions = $.extend(true, options.options || {} , Parsley.asyncValidators[validator].options);\n\n    // All `$.ajax(options)` could be overridden or extended directly from DOM in `data-parsley-remote-options`\n    ajaxOptions = $.extend(true, {}, {\n      url: url,\n      data: data,\n      type: 'GET'\n    }, remoteOptions);\n\n    // Generate store key based on ajax options\n    instance.trigger('field:ajaxoptions', instance, ajaxOptions);\n\n    csr = $.param(ajaxOptions);\n\n    // Initialise querry cache\n    if ('undefined' === typeof Parsley._remoteCache)\n      Parsley._remoteCache = {};\n\n    // Try to retrieve stored xhr\n    var xhr = Parsley._remoteCache[csr] = Parsley._remoteCache[csr] || $.ajax(ajaxOptions);\n\n    var handleXhr = function () {\n      var result = Parsley.asyncValidators[validator].fn.call(instance, xhr, url, options);\n      if (!result) // Map falsy results to rejected promise\n        result = $.Deferred().reject();\n      return $.when(result);\n    };\n\n    return xhr.then(handleXhr, handleXhr);\n  },\n\n  priority: -1\n});\n\nParsley.on('form:submit', function () {\n  Parsley._remoteCache = {};\n});\n\nwindow.ParsleyExtend.addAsyncValidator = function () {\n  Utils.warnOnce('Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`');\n  return Parsley.addAsyncValidator(...arguments);\n};\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/parsley/ui.js":"import $ from 'jquery';\nimport Utils from './utils';\n\nvar UI = {};\n\nvar diffResults = function (newResult, oldResult, deep) {\n  var added = [];\n  var kept = [];\n\n  for (var i = 0; i < newResult.length; i++) {\n    var found = false;\n\n    for (var j = 0; j < oldResult.length; j++)\n      if (newResult[i].assert.name === oldResult[j].assert.name) {\n        found = true;\n        break;\n      }\n\n    if (found)\n      kept.push(newResult[i]);\n    else\n      added.push(newResult[i]);\n  }\n\n  return {\n    kept: kept,\n    added: added,\n    removed: !deep ? diffResults(oldResult, newResult, true).added : []\n  };\n};\n\nUI.Form = {\n\n  _actualizeTriggers: function () {\n    this.$element.on('submit.Parsley', evt => { this.onSubmitValidate(evt); });\n    this.$element.on('click.Parsley', Utils._SubmitSelector, evt => { this.onSubmitButton(evt); });\n\n    // UI could be disabled\n    if (false === this.options.uiEnabled)\n      return;\n\n    this.$element.attr('novalidate', '');\n  },\n\n  focus: function () {\n    this._focusedField = null;\n\n    if (true === this.validationResult || 'none' === this.options.focus)\n      return null;\n\n    for (var i = 0; i < this.fields.length; i++) {\n      var field = this.fields[i];\n      if (true !== field.validationResult && field.validationResult.length > 0 && 'undefined' === typeof field.options.noFocus) {\n        this._focusedField = field.$element;\n        if ('first' === this.options.focus)\n          break;\n      }\n    }\n\n    if (null === this._focusedField)\n      return null;\n\n    return this._focusedField.focus();\n  },\n\n  _destroyUI: function () {\n    // Reset all event listeners\n    this.$element.off('.Parsley');\n  }\n\n};\n\nUI.Field = {\n\n  _reflowUI: function () {\n    this._buildUI();\n\n    // If this field doesn't have an active UI don't bother doing something\n    if (!this._ui)\n      return;\n\n    // Diff between two validation results\n    var diff = diffResults(this.validationResult, this._ui.lastValidationResult);\n\n    // Then store current validation result for next reflow\n    this._ui.lastValidationResult = this.validationResult;\n\n    // Handle valid / invalid / none field class\n    this._manageStatusClass();\n\n    // Add, remove, updated errors messages\n    this._manageErrorsMessages(diff);\n\n    // Triggers impl\n    this._actualizeTriggers();\n\n    // If field is not valid for the first time, bind keyup trigger to ease UX and quickly inform user\n    if ((diff.kept.length || diff.added.length) && !this._failedOnce) {\n      this._failedOnce = true;\n      this._actualizeTriggers();\n    }\n  },\n\n  // Returns an array of field's error message(s)\n  getErrorsMessages: function () {\n    // No error message, field is valid\n    if (true === this.validationResult)\n      return [];\n\n    var messages = [];\n\n    for (var i = 0; i < this.validationResult.length; i++)\n      messages.push(this.validationResult[i].errorMessage ||\n       this._getErrorMessage(this.validationResult[i].assert));\n\n    return messages;\n  },\n\n  // It's a goal of Parsley that this method is no longer required [#1073]\n  addError: function (name, {message, assert, updateClass = true} = {}) {\n    this._buildUI();\n    this._addError(name, {message, assert});\n\n    if (updateClass)\n      this._errorClass();\n  },\n\n  // It's a goal of Parsley that this method is no longer required [#1073]\n  updateError: function (name, {message, assert, updateClass = true} = {}) {\n    this._buildUI();\n    this._updateError(name, {message, assert});\n\n    if (updateClass)\n      this._errorClass();\n  },\n\n  // It's a goal of Parsley that this method is no longer required [#1073]\n  removeError: function (name, {updateClass = true} = {}) {\n    this._buildUI();\n    this._removeError(name);\n\n    // edge case possible here: remove a standard Parsley error that is still failing in this.validationResult\n    // but highly improbable cuz' manually removing a well Parsley handled error makes no sense.\n    if (updateClass)\n      this._manageStatusClass();\n  },\n\n  _manageStatusClass: function () {\n    if (this.hasConstraints() && this.needsValidation() && true === this.validationResult)\n      this._successClass();\n    else if (this.validationResult.length > 0)\n      this._errorClass();\n    else\n      this._resetClass();\n  },\n\n  _manageErrorsMessages: function (diff) {\n    if ('undefined' !== typeof this.options.errorsMessagesDisabled)\n      return;\n\n    // Case where we have errorMessage option that configure an unique field error message, regardless failing validators\n    if ('undefined' !== typeof this.options.errorMessage) {\n      if ((diff.added.length || diff.kept.length)) {\n        this._insertErrorWrapper();\n\n        if (0 === this._ui.$errorsWrapper.find('.parsley-custom-error-message').length)\n          this._ui.$errorsWrapper\n            .append(\n              $(this.options.errorTemplate)\n              .addClass('parsley-custom-error-message')\n            );\n\n        return this._ui.$errorsWrapper\n          .addClass('filled')\n          .find('.parsley-custom-error-message')\n          .html(this.options.errorMessage);\n      }\n\n      return this._ui.$errorsWrapper\n        .removeClass('filled')\n        .find('.parsley-custom-error-message')\n        .remove();\n    }\n\n    // Show, hide, update failing constraints messages\n    for (var i = 0; i < diff.removed.length; i++)\n      this._removeError(diff.removed[i].assert.name);\n\n    for (i = 0; i < diff.added.length; i++)\n      this._addError(diff.added[i].assert.name, {message: diff.added[i].errorMessage, assert: diff.added[i].assert});\n\n    for (i = 0; i < diff.kept.length; i++)\n      this._updateError(diff.kept[i].assert.name, {message: diff.kept[i].errorMessage, assert: diff.kept[i].assert});\n  },\n\n\n  _addError: function (name, {message, assert}) {\n    this._insertErrorWrapper();\n    this._ui.$errorsWrapper\n      .addClass('filled')\n      .append(\n        $(this.options.errorTemplate)\n        .addClass('parsley-' + name)\n        .html(message || this._getErrorMessage(assert))\n      );\n  },\n\n  _updateError: function (name, {message, assert}) {\n    this._ui.$errorsWrapper\n      .addClass('filled')\n      .find('.parsley-' + name)\n      .html(message || this._getErrorMessage(assert));\n  },\n\n  _removeError: function (name) {\n    this._ui.$errorsWrapper\n      .removeClass('filled')\n      .find('.parsley-' + name)\n      .remove();\n  },\n\n  _getErrorMessage: function (constraint) {\n    var customConstraintErrorMessage = constraint.name + 'Message';\n\n    if ('undefined' !== typeof this.options[customConstraintErrorMessage])\n      return window.Parsley.formatMessage(this.options[customConstraintErrorMessage], constraint.requirements);\n\n    return window.Parsley.getErrorMessage(constraint);\n  },\n\n  _buildUI: function () {\n    // UI could be already built or disabled\n    if (this._ui || false === this.options.uiEnabled)\n      return;\n\n    var _ui = {};\n\n    // Give field its Parsley id in DOM\n    this.$element.attr(this.options.namespace + 'id', this.__id__);\n\n    /** Generate important UI elements and store them in this **/\n    // $errorClassHandler is the $element that woul have parsley-error and parsley-success classes\n    _ui.$errorClassHandler = this._manageClassHandler();\n\n    // $errorsWrapper is a div that would contain the various field errors, it will be appended into $errorsContainer\n    _ui.errorsWrapperId = 'parsley-id-' + (this.options.multiple ? 'multiple-' + this.options.multiple : this.__id__);\n    _ui.$errorsWrapper = $(this.options.errorsWrapper).attr('id', _ui.errorsWrapperId);\n\n    // ValidationResult UI storage to detect what have changed bwt two validations, and update DOM accordingly\n    _ui.lastValidationResult = [];\n    _ui.validationInformationVisible = false;\n\n    // Store it in this for later\n    this._ui = _ui;\n  },\n\n  // Determine which element will have `parsley-error` and `parsley-success` classes\n  _manageClassHandler: function () {\n    // An element selector could be passed through DOM with `data-parsley-class-handler=#foo`\n    if ('string' === typeof this.options.classHandler && $(this.options.classHandler).length)\n      return $(this.options.classHandler);\n\n    // Class handled could also be determined by function given in Parsley options\n    var $handler = this.options.classHandler.call(this, this);\n\n    // If this function returned a valid existing DOM element, go for it\n    if ('undefined' !== typeof $handler && $handler.length)\n      return $handler;\n\n    return this._inputHolder();\n  },\n\n  _inputHolder: function() {\n    // if simple element (input, texatrea, select...) it will perfectly host the classes and precede the error container\n    if (!this.options.multiple || this.$element.is('select'))\n      return this.$element;\n\n    // But if multiple element (radio, checkbox), that would be their parent\n    return this.$element.parent();\n  },\n\n  _insertErrorWrapper: function () {\n    var $errorsContainer;\n\n    // Nothing to do if already inserted\n    if (0 !== this._ui.$errorsWrapper.parent().length)\n      return this._ui.$errorsWrapper.parent();\n\n    if ('string' === typeof this.options.errorsContainer) {\n      if ($(this.options.errorsContainer).length)\n        return $(this.options.errorsContainer).append(this._ui.$errorsWrapper);\n      else\n        Utils.warn('The errors container `' + this.options.errorsContainer + '` does not exist in DOM');\n    } else if ('function' === typeof this.options.errorsContainer)\n      $errorsContainer = this.options.errorsContainer.call(this, this);\n\n    if ('undefined' !== typeof $errorsContainer && $errorsContainer.length)\n      return $errorsContainer.append(this._ui.$errorsWrapper);\n\n    return this._inputHolder().after(this._ui.$errorsWrapper);\n  },\n\n  _actualizeTriggers: function () {\n    var $toBind = this._findRelated();\n    var trigger;\n\n    // Remove Parsley events already bound on this field\n    $toBind.off('.Parsley');\n    if (this._failedOnce)\n      $toBind.on(Utils.namespaceEvents(this.options.triggerAfterFailure, 'Parsley'), () => {\n        this._validateIfNeeded();\n      });\n    else if (trigger = Utils.namespaceEvents(this.options.trigger, 'Parsley')) {\n      $toBind.on(trigger, event => {\n        this._validateIfNeeded(event);\n      });\n    }\n  },\n\n  _validateIfNeeded: function (event) {\n    // For keyup, keypress, keydown, input... events that could be a little bit obstrusive\n    // do not validate if val length < min threshold on first validation. Once field have been validated once and info\n    // about success or failure have been displayed, always validate with this trigger to reflect every yalidation change.\n    if (event && /key|input/.test(event.type))\n      if (!(this._ui && this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold)\n        return;\n\n    if (this.options.debounce) {\n      window.clearTimeout(this._debounced);\n      this._debounced = window.setTimeout(() => this.validate(), this.options.debounce);\n    } else\n      this.validate();\n  },\n\n  _resetUI: function () {\n    // Reset all event listeners\n    this._failedOnce = false;\n    this._actualizeTriggers();\n\n    // Nothing to do if UI never initialized for this field\n    if ('undefined' === typeof this._ui)\n      return;\n\n    // Reset all errors' li\n    this._ui.$errorsWrapper\n      .removeClass('filled')\n      .children()\n      .remove();\n\n    // Reset validation class\n    this._resetClass();\n\n    // Reset validation flags and last validation result\n    this._ui.lastValidationResult = [];\n    this._ui.validationInformationVisible = false;\n  },\n\n  _destroyUI: function () {\n    this._resetUI();\n\n    if ('undefined' !== typeof this._ui)\n      this._ui.$errorsWrapper.remove();\n\n    delete this._ui;\n  },\n\n  _successClass: function () {\n    this._ui.validationInformationVisible = true;\n    this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass);\n  },\n  _errorClass: function () {\n    this._ui.validationInformationVisible = true;\n    this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass);\n  },\n  _resetClass: function () {\n    this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass);\n  }\n};\n\nexport default UI;\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/parsley/utils.js":"import $ from 'jquery';\n\nvar globalID = 1;\nvar pastWarnings = {};\n\nvar Utils = {\n  // Parsley DOM-API\n  // returns object from dom attributes and values\n  attr: function ($element, namespace, obj) {\n    var i;\n    var attribute;\n    var attributes;\n    var regex = new RegExp('^' + namespace, 'i');\n\n    if ('undefined' === typeof obj)\n      obj = {};\n    else {\n      // Clear all own properties. This won't affect prototype's values\n      for (i in obj) {\n        if (obj.hasOwnProperty(i))\n          delete obj[i];\n      }\n    }\n\n    if ('undefined' === typeof $element || 'undefined' === typeof $element[0])\n      return obj;\n\n    attributes = $element[0].attributes;\n    for (i = attributes.length; i--; ) {\n      attribute = attributes[i];\n\n      if (attribute && attribute.specified && regex.test(attribute.name)) {\n        obj[this.camelize(attribute.name.slice(namespace.length))] = this.deserializeValue(attribute.value);\n      }\n    }\n\n    return obj;\n  },\n\n  checkAttr: function ($element, namespace, checkAttr) {\n    return $element.is('[' + namespace + checkAttr + ']');\n  },\n\n  setAttr: function ($element, namespace, attr, value) {\n    $element[0].setAttribute(this.dasherize(namespace + attr), String(value));\n  },\n\n  generateID: function () {\n    return '' + globalID++;\n  },\n\n  /** Third party functions **/\n  // Zepto deserialize function\n  deserializeValue: function (value) {\n    var num;\n\n    try {\n      return value ?\n        value == \"true\" ||\n        (value == \"false\" ? false :\n        value == \"null\" ? null :\n        !isNaN(num = Number(value)) ? num :\n        /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\n        value)\n        : value;\n    } catch (e) { return value; }\n  },\n\n  // Zepto camelize function\n  camelize: function (str) {\n    return str.replace(/-+(.)?/g, function (match, chr) {\n      return chr ? chr.toUpperCase() : '';\n    });\n  },\n\n  // Zepto dasherize function\n  dasherize: function (str) {\n    return str.replace(/::/g, '/')\n      .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n      .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n      .replace(/_/g, '-')\n      .toLowerCase();\n  },\n\n  warn: function () {\n    if (window.console && 'function' === typeof window.console.warn)\n      window.console.warn(...arguments);\n  },\n\n  warnOnce: function(msg) {\n    if (!pastWarnings[msg]) {\n      pastWarnings[msg] = true;\n      this.warn(...arguments);\n    }\n  },\n\n  _resetWarnings: function () {\n    pastWarnings = {};\n  },\n\n  trimString: function(string) {\n    return string.replace(/^\\s+|\\s+$/g, '');\n  },\n\n  parse: {\n    date: function(string) {\n      let parsed = string.match(/^(\\d{4,})-(\\d\\d)-(\\d\\d)$/);\n      if (!parsed)\n        return null;\n      let [_, year, month, day] = parsed.map(x => parseInt(x, 10));\n      let date = new Date(year, month - 1, day);\n      if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day)\n        return null;\n      return date;\n    },\n    string: function(string) {\n      return string;\n    },\n    integer: function(string) {\n      if (isNaN(string))\n        return null;\n      return parseInt(string, 10);\n    },\n    number: function(string) {\n      if (isNaN(string))\n        throw null;\n      return parseFloat(string);\n    },\n    'boolean': function _boolean(string) {\n      return !(/^\\s*false\\s*$/i.test(string));\n    },\n    object: function(string) {\n      return Utils.deserializeValue(string);\n    },\n    regexp: function(regexp) {\n      var flags = '';\n\n      // Test if RegExp is literal, if not, nothing to be done, otherwise, we need to isolate flags and pattern\n      if (/^\\/.*\\/(?:[gimy]*)$/.test(regexp)) {\n        // Replace the regexp literal string with the first match group: ([gimy]*)\n        // If no flag is present, this will be a blank string\n        flags = regexp.replace(/.*\\/([gimy]*)$/, '$1');\n        // Again, replace the regexp literal string with the first match group:\n        // everything excluding the opening and closing slashes and the flags\n        regexp = regexp.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');\n      } else {\n        // Anchor regexp:\n        regexp = '^' + regexp + '$';\n      }\n      return new RegExp(regexp, flags);\n    }\n  },\n\n  parseRequirement: function(requirementType, string) {\n    var converter = this.parse[requirementType || 'string'];\n    if (!converter)\n      throw 'Unknown requirement specification: \"' + requirementType + '\"';\n    let converted = converter(string);\n    if (converted === null)\n      throw `Requirement is not a ${requirementType}: \"${string}\"`;\n    return converted;\n  },\n\n  namespaceEvents: function(events, namespace) {\n    events = this.trimString(events || '').split(/\\s+/);\n    if (!events[0])\n      return '';\n    return $.map(events, evt => `${evt}.${namespace}`).join(' ');\n  },\n\n  difference: function(array, remove) {\n    // This is O(N^2), should be optimized\n    let result = [];\n    $.each(array, (_, elem) => {\n      if (remove.indexOf(elem) == -1)\n        result.push(elem);\n    });\n    return result;\n  },\n\n  // Alter-ego to native Promise.all, but for jQuery\n  all: function(promises) {\n    // jQuery treats $.when() and $.when(singlePromise) differently; let's avoid that and add spurious elements\n    return $.when(...promises, 42, 42);\n  },\n\n  // Object.create polyfill, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill\n  objectCreate: Object.create || (function () {\n    var Object = function () {};\n    return function (prototype) {\n      if (arguments.length > 1) {\n        throw Error('Second argument not supported');\n      }\n      if (typeof prototype != 'object') {\n        throw TypeError('Argument must be an object');\n      }\n      Object.prototype = prototype;\n      var result = new Object();\n      Object.prototype = null;\n      return result;\n    };\n  })(),\n\n  _SubmitSelector: 'input[type=\"submit\"], button:submit'\n};\n\nexport default Utils;\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/parsley/validator.js":"import $ from 'jquery';\nimport Utils from './utils';\n\nvar convertArrayRequirement = function(string, length) {\n  var m = string.match(/^\\s*\\[(.*)\\]\\s*$/);\n  if (!m)\n    throw 'Requirement is not an array: \"' + string + '\"';\n  var values = m[1].split(',').map(Utils.trimString);\n  if (values.length !== length)\n    throw 'Requirement has ' + values.length + ' values when ' + length + ' are needed';\n  return values;\n};\n\nvar convertExtraOptionRequirement = function(requirementSpec, string, extraOptionReader) {\n  var main = null;\n  var extra = {};\n  for (var key in requirementSpec) {\n    if (key) {\n      var value = extraOptionReader(key);\n      if ('string' === typeof value)\n        value = Utils.parseRequirement(requirementSpec[key], value);\n      extra[key] = value;\n    } else {\n      main = Utils.parseRequirement(requirementSpec[key], string);\n    }\n  }\n  return [main, extra];\n};\n\n// A Validator needs to implement the methods `validate` and `parseRequirements`\n\nvar Validator = function(spec) {\n  $.extend(true, this, spec);\n};\n\nValidator.prototype = {\n  // Returns `true` iff the given `value` is valid according the given requirements.\n  validate: function(value, requirementFirstArg) {\n    if (this.fn) { // Legacy style validator\n\n      if (arguments.length > 3)  // If more args then value, requirement, instance...\n        requirementFirstArg = [].slice.call(arguments, 1, -1);  // Skip first arg (value) and last (instance), combining the rest\n      return this.fn(value, requirementFirstArg);\n    }\n\n    if ($.isArray(value)) {\n      if (!this.validateMultiple)\n        throw 'Validator `' + this.name + '` does not handle multiple values';\n      return this.validateMultiple(...arguments);\n    } else {\n      let instance = arguments[arguments.length - 1];\n      if (this.validateDate && instance._isDateInput()) {\n        arguments[0] = Utils.parse.date(arguments[0]);\n        if (arguments[0] === null)\n          return false;\n        return this.validateDate(...arguments);\n      }\n      if (this.validateNumber) {\n        if (isNaN(value))\n          return false;\n        arguments[0] = parseFloat(arguments[0]);\n        return this.validateNumber(...arguments);\n      }\n      if (this.validateString) {\n        return this.validateString(...arguments);\n      }\n      throw 'Validator `' + this.name + '` only handles multiple values';\n    }\n  },\n\n  // Parses `requirements` into an array of arguments,\n  // according to `this.requirementType`\n  parseRequirements: function(requirements, extraOptionReader) {\n    if ('string' !== typeof requirements) {\n      // Assume requirement already parsed\n      // but make sure we return an array\n      return $.isArray(requirements) ? requirements : [requirements];\n    }\n    var type = this.requirementType;\n    if ($.isArray(type)) {\n      var values = convertArrayRequirement(requirements, type.length);\n      for (var i = 0; i < values.length; i++)\n        values[i] = Utils.parseRequirement(type[i], values[i]);\n      return values;\n    } else if ($.isPlainObject(type)) {\n      return convertExtraOptionRequirement(type, requirements, extraOptionReader);\n    } else {\n      return [Utils.parseRequirement(type, requirements)];\n    }\n  },\n  // Defaults:\n  requirementType: 'string',\n\n  priority: 2\n\n};\n\nexport default Validator;\n","/home/travis/build/npmtest/node-npmtest-parsleyjs/node_modules/parsleyjs/src/parsley/validator_registry.js":"import $ from 'jquery';\nimport Utils from './utils';\nimport Defaults from './defaults';\nimport Validator from './validator';\n\nvar ValidatorRegistry = function (validators, catalog) {\n  this.__class__ = 'ValidatorRegistry';\n\n  // Default Parsley locale is en\n  this.locale = 'en';\n\n  this.init(validators || {}, catalog || {});\n};\n\nvar typeTesters =  {\n  email: /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i,\n\n  // Follow https://www.w3.org/TR/html5/infrastructure.html#floating-point-numbers\n  number: /^-?(\\d*\\.)?\\d+(e[-+]?\\d+)?$/i,\n\n  integer: /^-?\\d+$/,\n\n  digits: /^\\d+$/,\n\n  alphanum: /^\\w+$/i,\n\n  date: {\n    test: value => Utils.parse.date(value) !== null\n  },\n\n  url: new RegExp(\n      \"^\" +\n        // protocol identifier\n        \"(?:(?:https?|ftp)://)?\" + // ** mod: make scheme optional\n        // user:pass authentication\n        \"(?:\\\\S+(?::\\\\S*)?@)?\" +\n        \"(?:\" +\n          // IP address exclusion\n          // private & local networks\n          // \"(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})\" +   // ** mod: allow local networks\n          // \"(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n          // \"(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n          // IP address dotted notation octets\n          // excludes loopback network 0.0.0.0\n          // excludes reserved space >= 224.0.0.0\n          // excludes network & broacast addresses\n          // (first & last IP address of each class)\n          \"(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])\" +\n          \"(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}\" +\n          \"(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))\" +\n        \"|\" +\n          // host name\n          \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\" +\n          // domain name\n          \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\" +\n          // TLD identifier\n          \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\" +\n        \")\" +\n        // port number\n        \"(?::\\\\d{2,5})?\" +\n        // resource path\n        \"(?:/\\\\S*)?\" +\n      \"$\", 'i'\n    )\n};\ntypeTesters.range = typeTesters.number;\n\n// See http://stackoverflow.com/a/10454560/8279\nvar decimalPlaces = num => {\n  var match = ('' + num).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n  if (!match) { return 0; }\n  return Math.max(\n       0,\n       // Number of digits right of decimal point.\n       (match[1] ? match[1].length : 0) -\n       // Adjust for scientific notation.\n       (match[2] ? +match[2] : 0));\n};\n\n// parseArguments('number', ['1', '2']) => [1, 2]\nlet parseArguments = (type, args) => args.map(Utils.parse[type]);\n// operatorToValidator returns a validating function for an operator function, applied to the given type\nlet operatorToValidator = (type, operator) => {\n  return (value, ...requirementsAndInput) => {\n    requirementsAndInput.pop(); // Get rid of `input` argument\n    return operator(value, ...parseArguments(type, requirementsAndInput));\n  };\n};\n\nlet comparisonOperator = operator => ({\n  validateDate: operatorToValidator('date', operator),\n  validateNumber: operatorToValidator('number', operator),\n  requirementType: operator.length <= 2 ? 'string' : ['string', 'string'], // Support operators with a 1 or 2 requirement(s)\n  priority: 30\n});\n\nValidatorRegistry.prototype = {\n  init: function (validators, catalog) {\n    this.catalog = catalog;\n    // Copy prototype's validators:\n    this.validators = $.extend({}, this.validators);\n\n    for (var name in validators)\n      this.addValidator(name, validators[name].fn, validators[name].priority);\n\n    window.Parsley.trigger('parsley:validator:init');\n  },\n\n  // Set new messages locale if we have dictionary loaded in ParsleyConfig.i18n\n  setLocale: function (locale) {\n    if ('undefined' === typeof this.catalog[locale])\n      throw new Error(locale + ' is not available in the catalog');\n\n    this.locale = locale;\n\n    return this;\n  },\n\n  // Add a new messages catalog for a given locale. Set locale for this catalog if set === `true`\n  addCatalog: function (locale, messages, set) {\n    if ('object' === typeof messages)\n      this.catalog[locale] = messages;\n\n    if (true === set)\n      return this.setLocale(locale);\n\n    return this;\n  },\n\n  // Add a specific message for a given constraint in a given locale\n  addMessage: function (locale, name, message) {\n    if ('undefined' === typeof this.catalog[locale])\n      this.catalog[locale] = {};\n\n    this.catalog[locale][name] = message;\n\n    return this;\n  },\n\n  // Add messages for a given locale\n  addMessages: function (locale, nameMessageObject) {\n    for (var name in nameMessageObject)\n      this.addMessage(locale, name, nameMessageObject[name]);\n\n    return this;\n  },\n\n  // Add a new validator\n  //\n  //    addValidator('custom', {\n  //        requirementType: ['integer', 'integer'],\n  //        validateString: function(value, from, to) {},\n  //        priority: 22,\n  //        messages: {\n  //          en: \"Hey, that's no good\",\n  //          fr: \"Aye aye, pas bon du tout\",\n  //        }\n  //    })\n  //\n  // Old API was addValidator(name, function, priority)\n  //\n  addValidator: function (name, arg1, arg2) {\n    if (this.validators[name])\n      Utils.warn('Validator \"' + name + '\" is already defined.');\n    else if (Defaults.hasOwnProperty(name)) {\n      Utils.warn('\"' + name + '\" is a restricted keyword and is not a valid validator name.');\n      return;\n    }\n    return this._setValidator(...arguments);\n  },\n\n  updateValidator: function (name, arg1, arg2) {\n    if (!this.validators[name]) {\n      Utils.warn('Validator \"' + name + '\" is not already defined.');\n      return this.addValidator(...arguments);\n    }\n    return this._setValidator(...arguments);\n  },\n\n  removeValidator: function (name) {\n    if (!this.validators[name])\n      Utils.warn('Validator \"' + name + '\" is not defined.');\n\n    delete this.validators[name];\n\n    return this;\n  },\n\n  _setValidator: function (name, validator, priority) {\n    if ('object' !== typeof validator) {\n      // Old style validator, with `fn` and `priority`\n      validator = {\n        fn: validator,\n        priority: priority\n      };\n    }\n    if (!validator.validate) {\n      validator = new Validator(validator);\n    }\n    this.validators[name] = validator;\n\n    for (var locale in validator.messages || {})\n      this.addMessage(locale, name, validator.messages[locale]);\n\n    return this;\n  },\n\n  getErrorMessage: function (constraint) {\n    var message;\n\n    // Type constraints are a bit different, we have to match their requirements too to find right error message\n    if ('type' === constraint.name) {\n      var typeMessages = this.catalog[this.locale][constraint.name] || {};\n      message = typeMessages[constraint.requirements];\n    } else\n      message = this.formatMessage(this.catalog[this.locale][constraint.name], constraint.requirements);\n\n    return message || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage;\n  },\n\n  // Kind of light `sprintf()` implementation\n  formatMessage: function (string, parameters) {\n    if ('object' === typeof parameters) {\n      for (var i in parameters)\n        string = this.formatMessage(string, parameters[i]);\n\n      return string;\n    }\n\n    return 'string' === typeof string ? string.replace(/%s/i, parameters) : '';\n  },\n\n  // Here is the Parsley default validators list.\n  // A validator is an object with the following key values:\n  //  - priority: an integer\n  //  - requirement: 'string' (default), 'integer', 'number', 'regexp' or an Array of these\n  //  - validateString, validateMultiple, validateNumber: functions returning `true`, `false` or a promise\n  // Alternatively, a validator can be a function that returns such an object\n  //\n  validators: {\n    notblank: {\n      validateString: function(value) {\n        return /\\S/.test(value);\n      },\n      priority: 2\n    },\n    required: {\n      validateMultiple: function(values) {\n        return values.length > 0;\n      },\n      validateString: function(value) {\n        return /\\S/.test(value);\n      },\n      priority: 512\n    },\n    type: {\n      validateString: function(value, type, {step = 'any', base = 0} = {}) {\n        var tester = typeTesters[type];\n        if (!tester) {\n          throw new Error('validator type `' + type + '` is not supported');\n        }\n        if (!tester.test(value))\n          return false;\n        if ('number' === type) {\n          if (!/^any$/i.test(step || '')) {\n            var nb = Number(value);\n            var decimals = Math.max(decimalPlaces(step), decimalPlaces(base));\n            if (decimalPlaces(nb) > decimals) // Value can't have too many decimals\n              return false;\n            // Be careful of rounding errors by using integers.\n            var toInt = f => Math.round(f * Math.pow(10, decimals));\n            if ((toInt(nb) - toInt(base)) % toInt(step) != 0)\n              return false;\n          }\n        }\n        return true;\n      },\n      requirementType: {\n        '': 'string',\n        step: 'string',\n        base: 'number'\n      },\n      priority: 256\n    },\n    pattern: {\n      validateString: function(value, regexp) {\n        return regexp.test(value);\n      },\n      requirementType: 'regexp',\n      priority: 64\n    },\n    minlength: {\n      validateString: function (value, requirement) {\n        return value.length >= requirement;\n      },\n      requirementType: 'integer',\n      priority: 30\n    },\n    maxlength: {\n      validateString: function (value, requirement) {\n        return value.length <= requirement;\n      },\n      requirementType: 'integer',\n      priority: 30\n    },\n    length: {\n      validateString: function (value, min, max) {\n        return value.length >= min && value.length <= max;\n      },\n      requirementType: ['integer', 'integer'],\n      priority: 30\n    },\n    mincheck: {\n      validateMultiple: function (values, requirement) {\n        return values.length >= requirement;\n      },\n      requirementType: 'integer',\n      priority: 30\n    },\n    maxcheck: {\n      validateMultiple: function (values, requirement) {\n        return values.length <= requirement;\n      },\n      requirementType: 'integer',\n      priority: 30\n    },\n    check: {\n      validateMultiple: function (values, min, max) {\n        return values.length >= min && values.length <= max;\n      },\n      requirementType: ['integer', 'integer'],\n      priority: 30\n    },\n    min: comparisonOperator((value, requirement) => value >= requirement),\n    max: comparisonOperator((value, requirement) => value <= requirement),\n    range: comparisonOperator((value, min, max) => value >= min && value <= max),\n    equalto: {\n      validateString: function (value, refOrValue) {\n        var $reference = $(refOrValue);\n        if ($reference.length)\n          return value === $reference.val();\n        else\n          return value === refOrValue;\n      },\n      priority: 256\n    }\n  }\n};\n\nexport default ValidatorRegistry;\n"}